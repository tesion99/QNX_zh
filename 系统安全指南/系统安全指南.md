# 系统安全指南

### 安全矩阵

下表描述了安全问题与网络攻击以及QNX系统用于消除这些问题的安全特性

| 安全问题/攻击                | 描述                                                         | 解决方法                                                     |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 静态数据保密性               | 防止攻击者在系统不运行的情况下查看、修改或泄露系统上的敏感数据。 | 基于文件的加密(查看文件系统安全相关章节)                     |
| 数据完整性和代码签名         | 允许将系统资产打包在受完整性保护的容器中，该容器可以随时安装在系统上以供访问。 | QNX可信磁盘(查看文件系统安全相关章节) <br/>安全启动          |
| 不受限制地访问系统资源管理器 | 禁止未认证的系统组件访问系统资源管理器通道，或在其连接后限制它们能够请求的操作 | 安全策略<br/>POSIX权限/ACL(查看访问控制相关章节)             |
| 文件系统访问控制             | 限制各种进程访问文件系统对象                                 | POSIX权限/ACL(查看访问控制相关章节)                          |
| 不可信的代码执行             | 禁止攻击者从文件系统运行或加载不可信的二进制程序             | 路径信任                                                     |
| 重定向控制流                 | 禁止攻击者修改执行控制流程                                   | RELRO                                                        |
| 重复攻击                     | 使攻击者更难猜测代码在内存中的加载位置以进行漏洞利用         | 地址空间布局随机化(ASLR)                                     |
| 缓冲区溢出                   | 检测代码以减轻潜在的缓冲区溢出攻击                           | 使用强化函数支持编译代码(查看强化系统函数章节)               |
| 栈溢出                       | 检测代码以减轻潜在的栈溢出攻击                               | 使用堆栈金丝雀技术来编译代码(查看编译器防御章节)             |
| 泄露敏感系统信息             | 禁止攻击者查看系统上其他进程的私有信息                       | 保护/proc文件系统(查看/proc文件系统章节)<br/>安全策略        |
| 以最小权限执行进程           | 配置系统以限制进程权限，从而确保它们的任务以最少的需求权限运行 | 安全策略<br/>进程管理器能力<br/>POSIX权限/ACL(查看权限控制章节) |
| 设备硬件访问内核内存         | 禁止攻击者通过设备访问DMA进而访问任意地址                    | QNX系统内存管理单元管理器                                    |
| 拒绝服务                     | - 禁止关键系统运行时耗尽资源<br/>- 意外流量堵塞网络          | - C库中的资源限制(查看setrlimit())<br/>使用网络监狱将一组进程隔离到特定接口, IP地址, 或者协议 |
| 中间人攻击                   | 防止攻击者拦截网络之间的流量。                               | 使用网络监狱将一组进程隔离到特定接口, IP地址, 或者协议       |
| 网络监听                     | 监控网络敏感数据                                             | 同上                                                         |



### 安全特性概览

在今天的计算机环境中, 在保护系统免受恶意行为者侵害方面, 安全扮演了关键角色. 安全需要再系统设计开始就纳入考虑而不是后期确定. QNX系统的设计与致力于安全特性使它能避免与保护自身免受众多的攻击. 本手册提供了安全特性的概览以及在系统面临的安全问题中这些特性的应用. 这些信息将是系统设计者和软件开发者在适当的阶段考虑其设计中的安全因素

#### 进程保护

##### 栈保护

QNX系统支持栈cookie，并且所有的栈默认不可执行. 栈金丝雀技术可以在QNX系统应用与共享库预编译使启用.

栈金丝雀可以在函数返回之前检测从而使它们不会被修改(例如栈上分配的变量缓冲区溢出导致). 对栈上栈金丝雀的任何修改将导致进程终止

##### 堆保护

默认情况下, 堆上的分配被标记为不可执行

默认堆分配算法使用内联堆分配数据的 cookie 来检测堆损坏

##### 进程管理器能力

进程管理器能力避免了拥有超级用户权限的进程导致的风险.  进程管理器赋予进程权限基于给予进程的能力, 而不是基于是否进程拥有用户ID为0或者不为0

##### 强化的系统函数

QNX系统提供的众多系统函数强化了版本的C库会在编译期, 运行期或者如下条件满足时检查它们的参数

- 目标缓冲区潜在的溢出(如果编译器能够检测目标缓冲区的大小)
- 接受可变数量参数的函数缺少或有额外的参数

如果这些条件中的一个在编译期被检测到, 编译器报告一个错误. 如果该条件在运行期被检测到, 受影响的进程输出诊断信息并终止程序以减轻潜在危害. 运行时检查对性能的影响可以忽略不计, 因此强化的系统函数可以在开发与产品环境中使用.

强化系统函数可通过**_FORTIFY_SOURCE**特性测试宏启用, 你可以在编译期使用**-D_FORTIFY_SOURCE=[1|2]**来设置. 关于构建组件以使用强化系统函数的指导，参考**开发者安全特性**章节中的**强化系统函数**. 关于检测一个组件是否使用了强化系统函数的指导, 参考**系统集成者安全特性**章节中的**强化系统函数**

##### 可执行或可写可执行映射

进程可以在启动后放弃能力, 从而拒绝自己创建进一步的可执行文件或可写和可执行文件的映射. 此行为可以限制攻击者通过向进程注入可执行代码来利用进程的可能性.

更多信息, 请查看C库引用中的**procmgr_ability()**函数

##### 进程资源限制(POSIX rlimits)

减少拒绝服务攻击影响的一种方式是使用资源限制. QNX系统支持对CPU使用, 内存使用, 打开连接和其他系统资源设置限制.

更多信息, 查看C库引用**prlimit()**函数

##### RELRO(重定位只读)

如果你在编译一个程序时启用了RELRO, 动态加载器完成可执行文件的加载和链接后, 编译器可以将可执行文件的重定位部分标记为只读. 

##### Pathtrust

QNX OS 可以使用一种称为 pathtrust 的机制来限制特权进程执行的代码. 如果特权进程被破坏, 攻击者无法通过将执行重定向到系统某处驻留的攻击者代码来进一步破坏系统.Pathtrust 使用 QNX Trusted Disk 和强制执行能力.

更多信息, 查看**Pathtrust**



#### 系统保护

##### 安全启动

支持从信任根进行安全启动. 安全启动依赖于所使用的SoC的支持.

##### 地址空间布局随机化

每次加载可执行文件时, 地址空间布局随机化都会改变数据和指令的位置. 这降低了攻击者能够利用所发现的任何漏洞进行攻击的可能性. 

##### 访问控制

支持 POSIX 权限模型以及访问控制列表 (ACL).

##### 安全策略

安全策略允许集中控制进程权限并避免需要进程自身去做复杂的安全决策

##### QNX可信磁盘

QNX 可信磁盘 (QTD) 设备提供只读文件系统的完整性保护, 并可将安全启动扩展到系统级文件系统. 它还可以作为完整性保护的容器. 

##### 基于文件的加密

强大安全的文件系统提供了基于文件加密的支持.

##### 加密支持

QNX系统提供了多种方式访问加密服务. 它提供了灵活的加密框架, 允许客户根据每个进程的响应请求选择哪一个加密供应商. 它还附带了流行的 OpenSSL 库和与旧式 /dev/crypto 系统设备交互的驱动程序.

##### 随机数生成器

可配置随机驱动程序为 /dev/random 和 /dev/urandom 系统接口提供服务. 

##### 认证

可插拔的认证模块 (OpenPAM) 可用于与认证相关的系统功能.

##### 驱动隔离

QNX OS 将文件系统, 网络和其他系统服务作为用户空间进程运行. 所有在进程保护列出的保护措施均可应用到作为用户空间进程运行的系统服务上, 从而限制系统服务漏洞的影响.

##### 硬件内存隔离

限制硬件访问系统内存的IOMMU技术是被支持的. 内存管理硬件的配置由SMMUMAM控制.

##### 额外功能与更多信息

一些功能或可用功能的指定特性特别吸引QNX系统项目的软件开发者或者系统集成者与安全专家.

查看Security for developers与Security for system integrators相关章节.



### 面向开发者的安全特性

#### 安全策略

安全策略让一些安全概念对开发者来说更容易理解

理想情况下, 没有资源管理器以 root 身份运行. 实现这一目标通常需要能力配置. 手动配置每个进程的进程管理器(procmgr)功能很容易出错.

当使用安全策略时, 开发者可以使用**libsecpol**提供的API, 而不是手动配置一个程序需要的特定权限. 当使用**libsecpol**库时, 开发者只需指示进程何时完成初始化. 开发者可以依靠安全策略来确保进程具有正确的权限集来启动以及正确的(希望是较小的)继续运行的权限集.

当特权进程必须生成具有不同特权要求的子进程时, **libsecpol**库可以使其更容易而无需开发者知道具体的要求是什么. 在所有子进程拥有相同特权的地方这种情况下, 安全策略允许通用的集合被配置而无需开发者进行任何操作.

通常, 处理请求的资源管理器很少依据客户端是否打开资源进行读取或写入来做出安全决策. **libsecpol** API提供了一系列进行更细粒度检查的函数, 这对于诸如 devctl() 调用之类的操作很有用. 

然后资源管理器通常必须能够同时在使用安全策略和不使用安全策略时工作. 当使用**libsecpol**时, 它可以在两种情况下工作，而无需编写代码来覆盖每种情况. 当不使用安全策略时, 系统并不安全但依然能够运行.

#### 栈保护

栈Cookie提供了在栈上分配变量导致栈溢出的保护，从而避免了程序的错误行为

可通过如下编译选项使这些功能生效

| 编译选项                     | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| **-fstack-protector**        | 保护在其堆栈上声明长度为八个字节或更长的字符数组的任何函数   |
| **-fstack-protector-all**    | 保护所有函数                                                 |
| **-fstack-protector-strong** | 介于前两者之间的平衡, 该选项的目的是通过扩大堆栈保护的范围而不是将其扩展到程序中的每个函数来获得性能, 同时牺牲很少的安全性 |

默认情况下, qcc隐式使用-fstack-protector-strong选项. 然后当你直接调用**ntoaarch64-gcc**或**ntox86_64-gcc**时, -fstack-protector-strong不会被隐式使用.

除此以外, 当你指定了如下编译或链接选项时, qcc也不会隐式使用-fstack-protector-strong 

- -fno-stack-protector
- -fstack-protector
- -fstack-protector-all
- -ffreestanding
- -nostdlib

默认情况下, 为 QNX OS 构建的二进制文件是使用非可执行堆栈构建的. 栈的可执行状态可以在一个类型为QNT_STACK的QNX特定ELF标记中找到.

如下示例命令检测了less的可执行状态

```shell
$ elfnote -t QNT_STACK -p less 

QNX specific note (name = QNX, type = 3) 
type : QNT_STACK 
stacksize : 0 
stackalloc : 4096 
executable : no 
hex : 000000000010000001000000 
```

更多关于QNX系统标记类型的信息, 请查看**elfnote**命令章节

你也可以使用**qchecksec**命令检测栈cookie是否启用以及栈的可执行状态, 请查看命令手册**qchecksec**相关条目

#### RELRO

在动态加载器完成加载和链接可执行程序之后, 编译器可以将可执行程序的重定位部分标记为只读. 如果出现.bss或数据段溢出bug, RELRO(Relocation Read-Only, 重定向只读)保护ELF二进制程序中的全局偏移表(Global Offset Table, GOT)免于被重写.

对于一些安全漏洞, 完整的RELRO技术提供了比局部RELRO更强的保护, 局部RELRO并不会是整个GOT只读. 然而, 完整的RELRO技术宅程序启动时会有性能影响.

启用局部RELRO使用如下的编译选项

```shell
-Wl,-z,relro 
```

完整的 RELRO 使过程链接表 (PLT) 以及 .got 和 .dtors 文件变为只读. 为了启用它, 将如下额外的命令行参数传递给动态链接器

```shell
-Wl,-z,now
```

当您使用 QNX OS 实用程序（通过 -Wl,-z,relro -Wl,-z,now 链接器标志）链接时，默认启用完整的 RELRO.

你可以使用**qchecksec**命令检测二进制程序是否启用了RELRO.



### 相关命令用法

#### on - 以非默认方式执行命令

语法

```shell
on [-A ability-spec] 		# 指定特定能力
   [-ad | -ae] 				# 禁用或启用ASLR(地址空间布局随机化)
   [-C cpunum]  			# 指定CPU, 从0开始
   [--critical] 			# 创建关键程序, 如果关键程序死亡, 则系统崩溃
   [-d] 					# 与父进程分离
   [-E] 					# 清空所有环境变量, 包括-e选项指定的
   [-e key=value]			# 设置环境变量
   [-h] 					# 以HELD状态启动命令
   [-L rlimit:cur[:max]] 	# 指定资源限制
   [-p priority[policy]]	# 指定优先级
   [-R runmask] 			# 指定运行时掩码
   [-S path] 				# 指定安全策略文件路径, 默认为/proc/boot/secpol.bin
   [-s] 					# 在新的进程组中生成命令
   [-T type] 				# 指定进程类型
   [-t tty]					# 指定终端
   [-u uid[:gid[,gid,…] | -u user_name]  # 以指定uid, gid的用户身份运行
   [-W nsec[:msec]] 		# 等待设备时间
   [-w device] 				# 指定等待的设备
   [-Xsched_command] 		# 使用指定的命令为外部调度程序启动
   [command [args]]			# 运行的命令及参数
```

示例

```shell
on -T serial_driver_t devc-ser8250
```

参考
	https://www.qnx.com/developers/docs/8.0/com.qnx.doc.neutrino.utilities/topic/o/on.html

#### slay - 通过名称或ID杀死或修改一个进程

语法

```shell
slay [-signal_number] 		 # 发送指定信号
	 [-C cpunum]			 # 指定CPU, 从0开始
	 [-f]					 # 强制在共享ID或进程名的所有进程上执行
	 [-h]					 # 发送SIGSTOP信号
	 [-i]					 # 设置继承掩码
	 [-m name|pid]			 # 限制只按照name或pid进行匹配
	 [-P prio[f|r|o]]		 # 指定优先级及调度策略, f:fifo, r:round-robin, o:other
	 [-p]					 # 打印进程ID
	 [-q]					 # 查询进程信息
	 [-Q]					 # 安静模式
	 [-R runmask]			 # 将CPU亲和性设置为 runmask
	 [-S]					 # 不杀死拥有子进程的进程
	 [-s signal_name]		 # 发送信号
	 [-T tid]				 # 将操作应用到指定的线程
	 [-t ttyname]			 # 匹配进程需拥有指定终端
	 [-u]				     # 发送一个SIGCONT信号
	 [-v]					 # 冗余模式, 显示更多信息
	 process_name|process_id # 进程名或ID
	 
```

Note:  slay命令不支持多个命令参数写一起的情况, 需单独分开

```shell
slay -u -v process
```

示例

```shell
slay -P 20 process
```

参考

​	https://www.qnx.com/developers/docs/8.0/com.qnx.doc.neutrino.utilities/topic/s/slay.html