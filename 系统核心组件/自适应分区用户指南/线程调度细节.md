# 线程调度细节

​	自适应分区线程调度程序是一个可选的线程调度程序，可让您保证线程、进程或应用程序组的 CPU 吞吐量的最小百分比。分配给分区的 CPU 百分比称为预算。

​	线程调度程序是在核心 QNX Neutrino RTOS 架构之上设计的，主要解决嵌入式系统设计中的两个问题：

- 在满载条件下正常运行
- 防止不重要或不受信任的应用程序垄断系统

我们称我们的分区是自适应的，因为它们的内容是动态的：

- 你可以将应用程序动态启动到分区中

- 子线程和子进程像其父进程一样，自动运行在相同的分区

- 默认情况下，当您使用标准 QNX Neutrino 发送-接收-回复消息传递时，消息接收方在处理该消息时会自动在消息发送方的分区中运行。

  这意味着所有资源管理器，例如驱动程序和文件系统，都会自动将 CPU 时间（开销除外）计入其客户的预算。

你可以通过命令行的**aps**命令或者在程序中调用**SchedCtl()**或**SchedCtl_r()**函数来控制自适应分区

Note:

​	在你调用**SchedCtl()**之前，请确保你传递给它的数据结构的所有成员被初始化。你可以使用**APS_INIT_DATA()**宏来实现。



## 跟踪 CPU 时间

​	自适应分区线程调度程序通过测量每个分区的平均 CPU 使用率来限制 CPU 使用率。 平均值是在平均窗口（通常为 100 毫秒）内计算的，该值是可配置的。

​	但是，线程调度程序不会等待 100 毫秒来计算平均值。 一旦 1 毫秒过去，这 1 毫秒的使用量就会添加到前 99 毫秒的使用量中，以计算平均窗口（即 100 毫秒）内的总 CPU 使用量。

​	窗口大小定义了平均时间；通过该时间，线程调度程序尝试将分区平衡到其保证的 CPU 限制。 您可以将平均窗口大小设置为 8 毫秒到 400 毫秒之间的任何值。

​	窗口大小的选择会影响平衡的准确性以及在极端情况下，还会影响运行线程的最大延迟。更多信息，请参考**线程调度器的注意事项**相关章节。

​	线程调度程序将花费的时间计入所用时钟滴答的实际部分。时间统计不仅在每个计时器滴答时完成，而且在每次线程开始或停止运行时完成。我们将此称为小额账单。



## CPU时间在分区间是如何分配的？

​	线程调度器是一个公平共享调度器。这意味着分区在需要时它可以获得定义的最小 CPU 时间量（它们的预算）。线程调度器也是一个实时调度器。这意味着它是一个抢占式的、基于优先级的调度程序。这两个要求似乎是冲突的，但是线程调度器通过优先级进行调度来满足这两个要求，这样它就不需要限制一个分区来保证其他分区的预算。

​	对于每个调度操作，线程调度程序在选择要运行的线程之前检查每个分区。这发生在每个定时器中断（通常是每毫秒）、每个消息/脉冲发送、接收或回复、每个信号、每个互斥锁操作和每个堆栈错误上，并且包括很多次进程管理器操作（进程或线程的创建/销毁 以及路径名称空间元素上的 open() 操作）

​	如果一个分区超出预算（意味着最近 100 毫秒消耗的 CPU 时间超过了分区的大小，并且其他分区也需要时间）并且线程想要运行，线程调度程序不会运行该线程；它将运行其他线程。仅当经过足够的时间以致该分区的平均 CPU 时间使用（过去 100 毫秒）低于分区的大小时，调度程序才会运行该线程。但是，线程保证最终会运行。



### 欠载

​	当分区在平均窗口内需要的 CPU 时间少于其定义的预算时，就会发生欠载。

​	每当分区的需求低于其预算时，线程调度程序就会在它们之间选择最高优先级的运行线程。换句话说，当负载不足时，线程调度器是一个严格的实时调度器。这是典型的 QNX Neutrino 调度。



### 空闲时间

​	空闲时间发生在一个分区未运行时。线程调度器将该分区的时间提供给其他正在运行的分区。如果其他正在运行的分区需要足够的时间，则允许它们超出预算。

​	如果一个分区偶然超出预算，它必须偿还借用的时间，但只偿还调度器记住的(例如只有在最后一个窗口发生的借用)那么多。

例如，假设我们有如下这些分区：

- System分区，负载70%，但未运行任何线程
- 分区Pa, 负载20%, 以优先级9运行一个无限循环
- 分区Pb, 负载10%, 以优先级10运行一个无限循环

因为System分区没有请求时间，所以它的预算时间变为了空闲时间。如果你使用默认调度策略(SCHED_APS_SCHEDPOL_DEFAULT)，线程调度器分配剩余时间给系统中优先级最高的线程。在这种情况下，即为分区Pb中的无限循环线程。因此**aps show**命令可能输出如下

```
                    +-------- CPU Time -------+-- Critical Time --
Partition name   id | Budget |  Max |    Used | Budget |      Used
--------------------+-------------------------+-------------------
System            0 |    70% | 100% |   0.11% |  200ms |   0.000ms
Pa                1 |    20% | 100% |  20.02% |    0ms |   0.000ms
Pb                2 |    10% | 100% |  79.83% |    0ms |   0.000ms
--------------------+-------------------------+-------------------
Total               |   100% |      |  99.95% |
```

​	在这个例子中，分区Pa收到它所保障的最小20%时间，但所有的剩余空闲时间给予了分区Pb。这是因为线程调度器严格按照分区间的优先级进行选择，只要没有分区被限制在其预算范围内即可。

​	但是，在某些情况下，您可能不希望分区 Pb 仅仅因为它具有最高优先级的线程而获得所有空闲时间。例如，您可能正在使用 Pb 来封装不受信任的或第三方应用程序。在这类情况下，你可能想使用**SchedCtl()**函数或者**aps modify -S**命令来指定一个不同的调度策略：**SCHED_APS_SCHEDPOL_FREETIME_BY_RATIO**

```shell
aps modify -S freetime_by_ratio
```

根据繁忙分区的预算比例划分空闲时间。在我们的例子中，freetime-by-ratio模式可能会使**aps show**显示如下

```
                    +-------- CPU Time -------+-- Critical Time --
Partition name   id | Budget |  Max |    Used | Budget |      Used
--------------------+-------------------------+-------------------
System            0 |    70% | 100% |   0.04% |  200ms |   0.000ms
Pa                1 |    20% | 100% |  65.96% |    0ms |   0.000ms
Pb                2 |    10% | 100% |  33.96% |    0ms |   0.000ms
--------------------+-------------------------+-------------------
Total               |   100% |      |  99.96% |
```

​	该图展示了在freetime-by-ratio模式下，线程调度器在分区Pa与Pb之间粗暴的以2:1的比率划分空闲时间，这个比率正是他们预算的比率。

**SCHED_APS_SCHEDPOL_PARTITION_LOCAL_PRIORITIES**

```shell
aps modify -S partition_local_priorities
```

​	纯粹按预算比例调度； 无论窗口大小如何，调度程序都会尝试在尽可能短的时间范围内平衡预算。这意味着具有大预算的高优先级分区不会运行完成（虽然它们有预算）； 它们与其他分区（甚至是低优先级分区）进行时间分割。此策略可以减少负载系统中小预算分区所见的延迟，但是您不会得到当所有分区都有预算（即默认策略）时发生的严格优先级抢占行为。

​	该选项包含了SCHED_APS_SCHEDPOL_FREETIME_BY_RATIO的行为。

​	当关键线程消耗关键时间时，它会暂时强制恢复到默认调度策略。关键线程被运行完成并不会被SCHED_APS_SCHEDPOL_PARTITION_LOCAL_PRIORITIES尝试平衡预算而导致时间分片。换句话说，关键线程不受该策略影响。

Note: 如果你正在一个0预算的分区中运行线程，请不要使用该调度策略。因为该策略按预算比率划分时间，一个0预算的分区永远不会被调度。

**SCHED_APS_SCHEDPOL_LIMIT_CPU_USAGE**

```shell
aps modify -S limit_cpu_usage
```

​	强制执行 max_budget_percent 参数，限制分区在系统负载不足时可以超出其正常预算的数量。如果未设置此选项，则在设置参数时将忽略 max_budget_percent，并报告为 100%（意味着空闲时间使用没有限制）。

Note: 一个分区中的线程，如果正常预算为0或者max_budget_percent 为0，该线程将永远不会运行。



### 满载

​	当所有分区都需要全部预算时，就会出现满载。一个简单的展示方式是在所有示例分区中运行一个while(1)的循环。在这种情况下，aps show命令显示如下：

```
                    +-------- CPU Time -------+-- Critical Time --
Partition name   id | Budget |  Max |    Used | Budget |      Used
--------------------+-------------------------+-------------------
System            0 |    70% | 100% |  69.80% |  200ms |   0.000ms
Pa                1 |    20% | 100% |  19.99% |    0ms |   0.000ms
Pb                2 |    10% | 100% |   9.81% |    0ms |   0.000ms
--------------------+-------------------------+-------------------
Total               |   100% |      |  99.61% |
```

​	在此示例中，满足分区保证预算的要求优先于优先级。

​	通常，当分区达到或超过其预算时，线程调度程序将它们之间的时间除以它们的预算比率，并将使用量平衡到分区预算的几个百分点。

​	即使在满载时，线程调度程序也可以为一组可工程的关键线程提供实时延迟。然而，在那种情况下，关键线程的调度优先于满足预算。

### 调度行为总结

如下表格总结了线程调度器在正常和freetime-by-ratio模式下分配时间

| 分区状态                     | 正常模式   | freetime-by-ratio |
| ---------------------------- | ---------- | ----------------- |
| 使用率 < 预算                | 按优先级   | 按优先级          |
| 使用率 > 预算 并且有空闲时间 | 按优先级   | 按预算比率        |
| 满载                         | 按预算比率 | 按预算比率        |
| 分区运行于关键线程           | 按优先级   | 按优先级          |

Note: 调度器的开销不会随着线程数的增加而增加；但是，它可能会随着分区数量的增加而增加，因此您应该使用尽可能少的分区。



## 分区继承

​	每当一个处于NQX Neutrino系统发送-接收-回复消息方案中服务器线程从一个客户端接收消息时，操作系统就认为该服务器线程正代表客户端工作。因此QNX Neutrino(中微子)以客户端的优先级运行该服务线程。换句话说，接收消息的线程继承了消息发送者的优先级。

​	有了线程调度器，这个概念得到了扩展；当服务器代表该客户端工作时，我们在客户端线程所在的分区中运行该服务线程。因此接收方的时间被计入发送方的调度程序分区。

**服务器创建的任何线程或进程怎么样？ 它们在哪个分区运行？**

- 新线程 - 如果你从另一个分区接收消息，并且你创建一个新线程作为响应，子线程将运行在发送者的分区直到子线程变为接收阻塞状态。那时，子线程的分区被重置为其创建者的分区。
- 新进程 - 如果你从另一个分区接收消息，并且你创建了一个子进程作为响应，子进程在发送者的分区创建。任何该子进程创建的线程也运行于发送者所在分区。

Note:  

​	如果你不想服务器或他创建的任何线程或进程运行在客户端所在分区，当服务器创建它的管道时设置**_NTO_CHF_FIXED_PRIORITY **标志。更多信息请参考**ChannelCreate()**接口说明。

​	发送-接收-回复消息传递是线程通信的唯一形式，它自动使服务器继承客户端的分区。

​	Pluse不继承发送者的分区。相反，它们的处理程序运行于进程pulse处理的分区，该分区默认为进程初始被创建的分区。你可以修改pulse处理分区，在**SchedCtl()**中指定进程ID以及-1的线程ID，设置**SCHED_APS_JOIN_PARTITION**命令







