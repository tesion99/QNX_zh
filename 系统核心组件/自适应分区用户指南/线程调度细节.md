# 线程调度细节

​	自适应分区线程调度程序是一个可选的线程调度程序，可让您保证线程、进程或应用程序组的 CPU 吞吐量的最小百分比。分配给分区的 CPU 百分比称为预算。

​	线程调度程序是在核心 QNX Neutrino RTOS 架构之上设计的，主要解决嵌入式系统设计中的两个问题：

- 在满载条件下正常运行
- 防止不重要或不受信任的应用程序垄断系统

我们称我们的分区是自适应的，因为它们的内容是动态的：

- 你可以将应用程序动态启动到分区中

- 子线程和子进程像其父进程一样，自动运行在相同的分区

- 默认情况下，当您使用标准 QNX Neutrino 发送-接收-回复消息传递时，消息接收方在处理该消息时会自动在消息发送方的分区中运行。

  这意味着所有资源管理器，例如驱动程序和文件系统，都会自动将 CPU 时间（开销除外）计入其客户的预算。

你可以通过命令行的**aps**命令或者在程序中调用**SchedCtl()**或**SchedCtl_r()**函数来控制自适应分区

Note:

​	在你调用**SchedCtl()**之前，请确保你传递给它的数据结构的所有成员被初始化。你可以使用**APS_INIT_DATA()**宏来实现。



## 跟踪 CPU 时间

​	自适应分区线程调度程序通过测量每个分区的平均 CPU 使用率来限制 CPU 使用率。 平均值是在平均窗口（通常为 100 毫秒）内计算的，该值是可配置的。

​	但是，线程调度程序不会等待 100 毫秒来计算平均值。 一旦 1 毫秒过去，这 1 毫秒的使用量就会添加到前 99 毫秒的使用量中，以计算平均窗口（即 100 毫秒）内的总 CPU 使用量。

​	窗口大小定义了平均时间；通过该时间，线程调度程序尝试将分区平衡到其保证的 CPU 限制。 您可以将平均窗口大小设置为 8 毫秒到 400 毫秒之间的任何值。

​	窗口大小的选择会影响平衡的准确性以及在极端情况下，还会影响运行线程的最大延迟。更多信息，请参考**线程调度器的注意事项**相关章节。

​	线程调度程序将花费的时间计入所用时钟滴答的实际部分。时间统计不仅在每个计时器滴答时完成，而且在每次线程开始或停止运行时完成。我们将此称为小额账单。



## CPU时间在分区间是如何分配的？

​	线程调度器是一个公平共享调度器。这意味着分区在需要时它可以获得定义的最小 CPU 时间量（它们的预算）。线程调度器也是一个实时调度器。这意味着它是一个抢占式的、基于优先级的调度程序。这两个要求似乎是冲突的，但是线程调度器通过优先级进行调度来满足这两个要求，这样它就不需要限制一个分区来保证其他分区的预算。

​	对于每个调度操作，线程调度程序在选择要运行的线程之前检查每个分区。这发生在每个定时器中断（通常是每毫秒）、每个消息/脉冲发送、接收或回复、每个信号、每个互斥锁操作和每个堆栈错误上，并且包括很多次进程管理器操作（进程或线程的创建/销毁 以及路径名称空间元素上的 open() 操作）

​	如果一个分区超出预算（意味着最近 100 毫秒消耗的 CPU 时间超过了分区的大小，并且其他分区也需要时间）并且线程想要运行，线程调度程序不会运行该线程；它将运行其他线程。仅当经过足够的时间以致该分区的平均 CPU 时间使用（过去 100 毫秒）低于分区的大小时，调度程序才会运行该线程。但是，线程保证最终会运行。



### 欠载

​	当分区在平均窗口内需要的 CPU 时间少于其定义的预算时，就会发生欠载。

​	每当分区的需求低于其预算时，线程调度程序就会在它们之间选择最高优先级的运行线程。换句话说，当负载不足时，线程调度器是一个严格的实时调度器。这是典型的 QNX Neutrino 调度。



### 空闲时间

​	空闲时间发生在一个分区未运行时。线程调度器将该分区的时间提供给其他正在运行的分区。如果其他正在运行的分区需要足够的时间，则允许它们超出预算。

​	如果一个分区偶然超出预算，它必须偿还借用的时间，但只偿还调度器记住的(例如只有在最后一个窗口发生的借用)那么多。

例如，假设我们有如下这些分区：

- System分区，负载70%，但未运行任何线程
- 分区Pa, 负载20%, 以优先级9运行一个无限循环
- 分区Pb, 负载10%, 以优先级10运行一个无限循环

因为System分区没有请求时间，所以它的预算时间变为了空闲时间。如果你使用默认调度策略(SCHED_APS_SCHEDPOL_DEFAULT)，线程调度器分配剩余时间给系统中优先级最高的线程。在这种情况下，即为分区Pb中的无限循环线程。因此**aps show**命令可能输出如下

```
                    +-------- CPU Time -------+-- Critical Time --
Partition name   id | Budget |  Max |    Used | Budget |      Used
--------------------+-------------------------+-------------------
System            0 |    70% | 100% |   0.11% |  200ms |   0.000ms
Pa                1 |    20% | 100% |  20.02% |    0ms |   0.000ms
Pb                2 |    10% | 100% |  79.83% |    0ms |   0.000ms
--------------------+-------------------------+-------------------
Total               |   100% |      |  99.95% |
```

​	在这个例子中，分区Pa收到它所保障的最小20%时间，但所有的剩余空闲时间给予了分区Pb。这是因为线程调度器严格按照分区间的优先级进行选择，只要没有分区被限制在其预算范围内即可。

​	但是，在某些情况下，您可能不希望分区 Pb 仅仅因为它具有最高优先级的线程而获得所有空闲时间。例如，您可能正在使用 Pb 来封装不受信任的或第三方应用程序。在这类情况下，你可能想使用**SchedCtl()**函数或者**aps modify -S**命令来指定一个不同的调度策略：**SCHED_APS_SCHEDPOL_FREETIME_BY_RATIO**

```shell
aps modify -S freetime_by_ratio
```

根据繁忙分区的预算比例划分空闲时间。在我们的例子中，freetime-by-ratio模式可能会使**aps show**显示如下

```
                    +-------- CPU Time -------+-- Critical Time --
Partition name   id | Budget |  Max |    Used | Budget |      Used
--------------------+-------------------------+-------------------
System            0 |    70% | 100% |   0.04% |  200ms |   0.000ms
Pa                1 |    20% | 100% |  65.96% |    0ms |   0.000ms
Pb                2 |    10% | 100% |  33.96% |    0ms |   0.000ms
--------------------+-------------------------+-------------------
Total               |   100% |      |  99.96% |
```

​	该图展示了在freetime-by-ratio模式下，线程调度器在分区Pa与Pb之间粗暴的以2:1的比率划分空闲时间，这个比率正是他们预算的比率。

**SCHED_APS_SCHEDPOL_PARTITION_LOCAL_PRIORITIES**

```shell
aps modify -S partition_local_priorities
```

​	纯粹按预算比例调度； 无论窗口大小如何，调度程序都会尝试在尽可能短的时间范围内平衡预算。这意味着具有大预算的高优先级分区不会运行完成（虽然它们有预算）； 它们与其他分区（甚至是低优先级分区）进行时间分割。此策略可以减少负载系统中小预算分区所见的延迟，但是您不会得到当所有分区都有预算（即默认策略）时发生的严格优先级抢占行为。

​	该选项包含了SCHED_APS_SCHEDPOL_FREETIME_BY_RATIO的行为。

​	当关键线程消耗关键时间时，它会暂时强制恢复到默认调度策略。关键线程被运行完成并不会被SCHED_APS_SCHEDPOL_PARTITION_LOCAL_PRIORITIES尝试平衡预算而导致时间分片。换句话说，关键线程不受该策略影响。

Note: 如果你正在一个0预算的分区中运行线程，请不要使用该调度策略。因为该策略按预算比率划分时间，一个0预算的分区永远不会被调度。

**SCHED_APS_SCHEDPOL_LIMIT_CPU_USAGE**

```shell
aps modify -S limit_cpu_usage
```

​	强制执行 max_budget_percent 参数，限制分区在系统负载不足时可以超出其正常预算的数量。如果未设置此选项，则在设置参数时将忽略 max_budget_percent，并报告为 100%（意味着空闲时间使用没有限制）。

Note: 一个分区中的线程，如果正常预算为0或者max_budget_percent 为0，该线程将永远不会运行。



### 满载

​	当所有分区都需要全部预算时，就会出现满载。一个简单的展示方式是在所有示例分区中运行一个while(1)的循环。在这种情况下，aps show命令显示如下：

```
                    +-------- CPU Time -------+-- Critical Time --
Partition name   id | Budget |  Max |    Used | Budget |      Used
--------------------+-------------------------+-------------------
System            0 |    70% | 100% |  69.80% |  200ms |   0.000ms
Pa                1 |    20% | 100% |  19.99% |    0ms |   0.000ms
Pb                2 |    10% | 100% |   9.81% |    0ms |   0.000ms
--------------------+-------------------------+-------------------
Total               |   100% |      |  99.61% |
```

​	在此示例中，满足分区保证预算的要求优先于优先级。

​	通常，当分区达到或超过其预算时，线程调度程序将它们之间的时间除以它们的预算比率，并将使用量平衡到分区预算的几个百分点。

​	即使在满载时，线程调度程序也可以为一组可工程的关键线程提供实时延迟。然而，在那种情况下，关键线程的调度优先于满足预算。

### 调度行为总结

如下表格总结了线程调度器在正常和freetime-by-ratio模式下分配时间

| 分区状态                     | 正常模式   | freetime-by-ratio |
| ---------------------------- | ---------- | ----------------- |
| 使用率 < 预算                | 按优先级   | 按优先级          |
| 使用率 > 预算 并且有空闲时间 | 按优先级   | 按预算比率        |
| 满载                         | 按预算比率 | 按预算比率        |
| 分区运行于关键线程           | 按优先级   | 按优先级          |

Note: 调度器的开销不会随着线程数的增加而增加；但是，它可能会随着分区数量的增加而增加，因此您应该使用尽可能少的分区。



## 分区继承

​	每当一个处于NQX Neutrino系统发送-接收-回复消息方案中服务器线程从一个客户端接收消息时，操作系统就认为该服务器线程正代表客户端工作。因此QNX Neutrino(中微子)以客户端的优先级运行该服务线程。换句话说，接收消息的线程继承了消息发送者的优先级。

​	有了线程调度器，这个概念得到了扩展；当服务器代表该客户端工作时，我们在客户端线程所在的分区中运行该服务线程。因此接收方的时间被计入发送方的调度程序分区。

**服务器创建的任何线程或进程怎么样？ 它们在哪个分区运行？**

- 新线程 - 如果你从另一个分区接收消息，并且你创建一个新线程作为响应，子线程将运行在发送者的分区直到子线程变为接收阻塞状态。那时，子线程的分区被重置为其创建者的分区。
- 新进程 - 如果你从另一个分区接收消息，并且你创建了一个子进程作为响应，子进程在发送者的分区创建。任何该子进程创建的线程也运行于发送者所在分区。

Note:  

​	如果你不想服务器或他创建的任何线程或进程运行在客户端所在分区，当服务器创建它的管道时设置**_NTO_CHF_FIXED_PRIORITY **标志。更多信息请参考**ChannelCreate()**接口说明。

​	发送-接收-回复消息传递是线程通信的唯一形式，它自动使服务器继承客户端的分区。

​	Pluse不继承发送者的分区。相反，它们的处理程序运行于进程pulse处理的分区，该分区默认为进程初始被创建的分区。你可以修改pulse处理分区，在**SchedCtl()**中指定进程ID以及-1的线程ID，设置**SCHED_APS_JOIN_PARTITION**命令



## 关键线程

​	关键线程是一个即使其分区超出预算也允许运行的线程(前提是该分区具有关键时间预算)。

​	当你创建一个分区时，你可以指定：

- 一个关键预算，如果分区已经耗尽其正常预算，则分区的关键线程在平均窗口期间可以使用的**毫秒数**
- 一个关键优先级；任何在分区中以关键优先级或更高优先级运行的线程可以使用该分区的关键预算

​	即使系统已满载，或同一分区中的其他线程受到限制以满足预算，关键线程依然会出现实时延迟。其基本思想是允许关键线程违反其分区的预算规则并立即运行，从而获得其所需的实时响应。为了让其正确运行，系统中不得运行太多的关键线程。如果关键线程占多数，则线程调度程序将很少能够保证所有分区的最低 CPU 预算，并且系统会降级为基于优先级的线程调度程序。

​	关键时间将根据分区计费，当满足如下条件时

- 运行分区的关键预算大于0
- 分区中顶级线程的优先级 大于等于 分区的关键优先级
- 运行的分区必须超出CPU预算百分比
- 必须至少有一个其他分区竞争CPU时间

否则关键时间不计费。无论时间是否按关键时间计费，关键线程都会运行。唯一一次关键线程不会运行是当其分区耗尽关键预算时。

​	为了使分区的关键预算无限，将其设置为处理器数量乘以平均窗口大小。请谨慎操作，因为这可能导致安全问题。更多请查看**调度器分区安全**相关章节。

#### 破产

​	当分区的关键CPU时间超过其关键预算时，就会发生破产(Bankruptcy )

Note: System分区的关键预算是无穷的，该分区永远不会破产。

​	测试在系统满载情况下确保一切正常运行，尤其是确保你已经选择了正确的关键预算，这是很重要的。一个验证的方式是在每个分区运行一个while(1)的线程来消费掉所有可用的时间。

​	bankruptcy被认为是一个应用程序方面的设计错误，但系统的响应是可配置的。QNX Neutrino允许你设置一个恢复策略，选项如下：

- Basic(默认)

  ​	传递破产通知时间，并使该分区在调度窗口的剩余时间内超出预算。

  ​	如果你想被一个破产通知，正确设置一个**sigevent**，然后调用**procmgr_event_notify()**或**procmgr_event_notify_add()**，并设置**PROCMGR_EVENT_APS_BANKRUPTCY **来注册该事件。

  当分区用完关键预算时，它将不允许继续运行直到它收到更多的预算，也就是说，滑动平均窗口会重新计算该分区的平均 CPU 消耗，使其略低于其配置的 CPU 预算。在破产后，必须经过足够的时间才能使计算出的分区平均 CPU 时间降至其配置的预算。至少，这意味着在再次调度该分区之前必须经过等于关键预算的毫秒数。

- Cancel

  cancel选项是破产分区的关键预算被设置为0。这将禁止该分区运行直到你恢复它的关键预算。或者通过 SchedCtl() 函数的 SCHED_APS_MODIFY_PARTITION 命令，或通过 aps modify 命令的 -B 选项。

- 强制重启

  使系统崩溃，并提供一条简短的消息来标识有问题的分区。这适用于您的回归测试。

你可以设置破产策略，使用**aps**命令或通过**SchedCtl()**函数设置**SCHED_APS_SET_PARAM**命令。



### 自适应分区线程调度器和其他线程调度器

​	优先级和线程调度策略仅与一个自适应分区相关；优先级顺序在分区内被遵守，但如果线程调度器需要平衡预算，则在分区之间该顺序不被遵守。你可以将线程调度器与现有的FIFO、轮询和零星调度策略结合使用。然而，调度器可能会在线程的时间片结束之前(轮询情况下)或线程运行完毕之前(FIFO情况下)停止线程的运行。

​	当线程的分区超出预算而其他分区有预算时，就会发生这种情况。也就是说，线程调度器不会等待线程时间片结束来确定是否从不同分区运行线程。调度器在每个时钟周期(在大多数机器上一个时钟周期为1毫秒)都会做出该决定。每个时间片有4个时钟周期。

**关于 FIFO 调度的注意事项**

请注意不要滥用 FIFO 调度策略。有一种技术可以在不使用互斥的情况下在一组线程间读取和写入共享数据：你可以使所有争夺共享数据的线程以相同优先级运行。

​	因为一次只能运行一个线程(至少在单处理器系统上)，并且通过FIFO调度，一个线程永远不会中断另一个线程，每个线程在运行时都垄断共享数据。

​	这是糟糕的，因为对调度策略或优先级的任何意外修改都可能导致一个线程在其临界区(critical section)中间中断另一个线程。因此可能会导致代码崩溃。如果你不小心将使用此技术的线程放入不同的分区(或让他们从不同分区接收消息)，它们的临界区将被破坏。

​	如果你的应用的线程使用它们的优先级来控制他们运行的顺序，你应当总是将这些线程放在相同的分区，并且你不应从其他分区发送消息给这些线程。

​	写入依赖于基于优先级的以特定顺序执行的线程，应当总是始终放置于相同的分区中。并且你不应从其他分区发送消息给该线程。

​	为了解决这个问题，你必须使用互斥、屏障或脉冲来控制线程顺序。如果你在多核系统上运行应用程序，这可以避免出现问题。作为解决方法，你可以为**ChannelCreate()**指定**_NTO_CHF_FIXED_PRIORITY**标识，这会阻止接收线程在发送线程的分区中运行。

​	总的来说，为了互斥，你应当确保你的应用程序不依赖FIFO策略或时间片的长度。



### 一起使用线程调度器与多核





