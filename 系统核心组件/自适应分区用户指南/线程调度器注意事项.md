# 线程调度器注意事项

你通常使用线程调度器的目的

- 设计一个系统，使其在满载时，以可预测或可定义的方式工作
- 防止不重要或不受信任的应用独占系统

无论哪种情况，你都需要根据整个系统来配置线程调度器的参数。基本的考虑是

- 你应该创建多少个调度分区，以及每个分区应安装什么软件?
- 每个调度器分区应获得多少保证的CPU百分比?
- 每个调度器分区的关键预算(如果有)应该是多少?
- 时间平均窗口应该是多大? 以毫毛为单位



## 确定调度程序分区的数量及其内容

​	将功能相关的软件放于相同的分区是合理的，通常也是正确的选择。然而，自适应分区线程调度是一种决定何时不运行软件的结构化方式。因此，实际的方法是，如果软件在不同情况下需要CPU时间，则将软件分成不同的调度分区。

Note: 你能创建的最大分区数是32

例如，如果系统是一个数据包路由器，功能如下

- 路由数据包
- 收集并记录数据包路由的统计信息
- 处理对端路由器的路由拓扑协议
- 收集并记录路由拓扑指标

拥有两个调度分区似乎是合理的，一个用于路由，一个用于拓扑。当然记录路由指标在功能上与数据包路由相关。

然而，但系统过载时，这就意味着机器无法完成更多出色的工作，你需要决定什么工作可以缓慢地处理。在这个例子中，当路由器因传入的数据包而过载时，路由这些数据仍然是很重要的。但是你可能会做如此决定，如果你无法完成所有操作，你宁愿路由数据而不是收集路由指标。通过同样的分析，你可能会得出这样的结论：路由拓扑协议应该继续运行，其使用的机器资源比路由本身少的多，但在需要时可以快速运行。

如此分析后需要3个分区：

- 一个分区用于路由数据包，占有很大份额，比如80%
- 一个分区用于拓扑协议，占比15%，但其最大线程优先级应高于数据包路由的优先级
- 一个分区用于记录路由指标和拓扑协议指标

在这种情况下，我们选择分离路由与记录路由指标的功能相关的组件，因为如果我们被迫挨饿某样东西，我们宁愿只挨饿一个。同样，我们选择将两个功能不相关的组件分组，一个记录路由指标，一个记录拓扑指标，因为我们想在相同的环境下让它们挨饿。(挨饿指处于空闲，不被CPU调度)



## 选择每个分区的CPU百分比

​	每个调度分区在未加载条件下倾向于使用的CPU时间量是你可以分配给它的预算的一个好迹象。如果你的应用程序是一个事务处理器，测量几种不同负载下的 CPU 消耗并构建提供的负载与消耗的 CPU 的图表可能很有用。

​	通常，获取正确的分区预算组合的关键是尝试一下方式：

- 关闭安全功能
- 用实际负载加载测试机器
- 使用IDE的系统分析器工具检查对时间敏感的线程的延迟
- 尝试不同的预算模式，你可以通过**aps**命令在运行时轻松的修改

Note: 你不能删除分区，但是你可以移除它的所有相应的进程，并且然后修改特定分区的预算为0%



### 设置预算为0

​	只要未设置 SCHED_APS_SEC_NONZERO_BUDGETS 安全标志，就可以将分区的预算设置为零。请查看**SchedCtl()**的**SCHED_APS_ADD_SECURITY**命令

​	在0预算的分区中的线程只能以如下情况运行：

- 你正使用默认调度策略(SCHED_APS_SCHEDPOL_DEFAULT)，并且系统中最高优先级的线程属于0预算分区
- 你正使用SCHED_APS_SCHEDPOL_FREETIME_BY_RATION，并且所有其他非零预算分区是空闲的
- 0预算分区拥有一个非零的临界预算，在这种情况下其关键线程将运行
- 线程从一个非零预算的分区接收消息，在这种情况下接收线程临时运行于发送者的分区

**何时设置分区的预算为0是有用的呢？**

在如下情况，设置分区的预算为0是有用的：

- 一个分区运行的线程永远为空；你可以设置它的预算为0来有效关闭该分区。当一个0预算分区空闲时，它不被认为会产生空闲时间(查看本指南线程调度器章节中的调度行为概述)。一个非零预算且从不运行线程的分区将线程调度器永远至于空闲时间模式，这可能并不是希望的行为。
- 当一些其他分区空闲时，你想要运行非关键的代码
- 该分区由资源管理器或其他软件构成，它仅在响应接收消息时运行。将它们放置于0预算分区意味着你不必为它们单独设计分区预算。(那些资源管理器自动将其时间计入其客户端的分区)

Note: 通常，不建议将一个分区预算设置为0。(这就是为何**SCHED_APS_RECOMMENDED**安全设置不允许分区预算为0)将代码放入0预算分区的主要风险是它可能会运行以响应一个脉冲或事件，因此而不在发送者分区中运行。结果就是，当系统加载时(例如没有空闲时间)，这些线程不可能运行，它们可能挂起，或者事情可能会以错误的顺序发生。

​	例如，将System分区的预算设置为0是危险的。在一个System分区预算为0的加载过的机器上，请求**procnto**创建进程和线程可能会挂起，例如当**MAP_LAZY**被使用时。此外，如果你的系统使用0预算的分区，当所有其他分区在一个while(1)循环中满载时，你应该小心地测试它。



### 为资源管理器设置预算

​	理想情况下，我们希望资源管理器(例如文件系统)以零预算运行。这样它们就可以一直向客户端收取时间费用。然而，当某些设备驱动意识到一个特定线程正在为哪个客户端工作时已为时已晚。因此，一些设备驱动可能具有用于审核或维护请求的CPU时间(该时间不能归因于一个特定的客户端)的后台线程。在这些情况下，你应该测量资源管理器的背景和不可归因的负载，然后将这些金额添加到其分区的预算中。

**注意**

- 如果你的服务拥有一个永不服务客户端的维护线程，那么它将位于一个预算非零的分区。
- 如果你的服务通过发送消息、使用互斥或共享内存(等等，除了接收消息的其他东西)来与客户端通信，那么你的服务应位于一个预算非零的分区。

您可以将时间平均窗口的大小设置为 8 到 400 毫秒。这是线程调度程序尝试将调度程序分区平衡到其保证的 CPU 限制的时间。选择不同的窗口大小不仅会影响负载平衡的准确性，而且在极端情况下，还会影响准备运行线程的最大延迟。



## 选择窗口大小

### 准确性

考虑如下

- 较小的窗口大小会降低 CPU 时间平衡的准确性。误差为(tick_size / window_size)。

  例如，如果窗口大小为10毫秒，准确度约为10个百分点。

- 如果一个分区偶然超出预算(因为其他分区使用的预算低于其保证的预算)，则它必须偿还借用的时间，但仅偿还线程调度器记录的时间(即仅在最后一个窗口中发生的借用)。

  小窗口大小意味着机会主义超出预算的调度程序分区可能不需要偿还时间。如果一个分区休眠超过窗口大小，则稍后将无法恢复时间。因此，如果系统已加载并且某系分区休眠时间超过窗口大小，那么长远来看，负载均衡将不准确。

- 如果窗口大小足够小，以至于某些分区的预算百分比变得小于一个刻度，该分区将在每个窗口期间运行至少1个刻度，给它**1 tick / window_size_in_ticks**百分比的CPU时间，这可能比分区的实际预算大得多。因此，其他分区可能无法获得其 CPU 预算。



### 与优先级调度相比的延迟

​	在负载不足的情况下，线程调度器不会延迟准备运行的线程，但是如果线程调度器正在进行平衡预算，则最高优先级的线程可能不会运行。

​	在极不可能的情况下，较大的窗口大小可能会导致某些调度程序分区遇到运行时延迟。但这些延迟总是小于没有自适应分区线程调度时发生的延迟。有两种情况可能会发生这种情况。

**情形一**

如果一个调度器分区预算是budget毫秒，那么延迟绝不会长于：

​	*window_size - smallest_budget + largest_budget*

仅当低预算和低优先级调度程序分区以特定方式与其他两个调度程序分区交互时才会达到此上限，并且仅当系统中所有线程都准备好运行很长的时间间隔时才会。这种最大可能的延迟发生的可能性极低。

例如，给你如下这些调度器分区：

- 分区A： 10%份额，始终准备好以优先级10运行
- 分区B： 10%份额，当其运行时，优先级为20
- 分区C： 80%份额，当其运行时，优先级为30

当如下情况出现时，延迟会发生：

- 让B、C休眠一段较长时间。A将有机会运行并最终运行100ms(平均窗口的大小)
- 然后B唤醒。其拥有可用的预算与高优先级，因此它运行。我们称该时间为Ta，因为这是分区A最后一次运行。由于C继续休眠，B将有机会运行
- 在Ta + 90 ms时，分区A偿还所有它曾有机会使用过的所有时间(窗口大小减去分区A预算的10%)。通常，它会在下一个时钟周期运行，因为此时它的预算为 1 毫秒，而 B 超出了预算。
- 但假设，巧合的是，C 选择在那个确切的时间醒来。因为它拥有预算并且优先级高于A，C运行。在其预算用尽时，它运行了另一个80ms
- 直到现在，在 Ta + 90 ms + 80 ms，或 170 毫秒后，A 才再次运行。

除非高优先级分区恰好在低优先级分区刚刚完成偿还其机会运行时间时唤醒，否则这种情况不会发生。

**情形二**

虽然仍然很少见，但更常见的是 window_size - budget毫秒的延迟，这种情况可能发生在平均优先级与其他分区相同的低预算调度程序分区上。

对于典型的线程优先级组合，当准备运行时，每个调度程序分区通常会经历远小于 window_size 毫秒的最大延迟。

例如，假设我们有如下调度器分区：

- 分区A：10%份额，总是准备以优先级10运行

- 分区B：90%份额，总是准备以优先级20运行，除此外每150ms，休眠50ms

当如下情况出现时，延迟发生：

- 当B休眠，分区 A 已达到 10 毫秒的预算限制（窗口大小的 10%）。
- 当A有机会运行50ms，此时B唤醒。我们称此时为Ta，表示A最后一次运行
- B继续运行90ms，消耗其预算。然后A再次运行，此时为Ta之后90ms

然而，只有当 10% 的应用程序从不挂起（这极不可能），并且没有其他优先级的线程（也极不可能）时，才会出现这种模式。

### 估计延迟

由于这些场景很复杂，并且最大延迟时间是分区份额的函数，因此我们近似认为最大就绪队列延迟时间是窗口大小的两倍。

**注意**

​	如果在运行时更改系统的刻度大小，请在定义分区线程调度程序的窗口大小之前执行此操作，因为QNX Neutrino会将窗口大小从ms转换为时钟刻度用于内部使用。



验证调度延迟是否正确的实用方法是向系统加载压力负载，并使用 IDE 中的 System Profiler 工具来监控延迟。**aps**命令让你可以动态修改预算，因此你可以快速地确认你拥有正确的预算配置。



## 实际限制

如果你使用自适应分区，你需要知道一下限制：

- API 允许窗口大小短至 8 毫秒，但是实际的窗口大小需要更大一些。例如，在一个8个分区的系统中，所有分区都忙时，理所当然期望所有八个窗口在每个窗口期间运行，此时窗口大小至少需要8个时间片长，对大多数系统来说就是32ms
- 过载不会报告给用户。自适应分区调度器检测过载情况并限制一些分区以保证其他分区的百分比份额，但是它不会通知内核外部的任何东西关于过载被检测。问题在于过载可能发生(也可能不发生)在每次调度操作时，这种调度操作每秒钟会发生上千次。
- SCHED_RR 线程可能不会在平均窗口部分小于一个时间片的分区中进行轮询。例如，当时间片是4ms(默认)并且自适应分区调度器窗口大小是100ms(默认)时，SCHED_RR线程在一个份额为4%的分区中将不会正确的轮询。
- 如果您使用自适应分区和绑定多重处理 (BMP)，某些预算组合可能无法满足。零预算分区中的线程应当仅在所有其他非零分区空闲时运行。在 SMP 计算机上，当某些其他分区需要时间时，零预算分区可能无法正确运行。在任何时候，所有分区的最低预算仍然会得到保证，并且如果所有非零分区准备运行，则零预算分区将不会运行。



## 调度程序分区之间不受控制的交互

在某些情况下，调度程序分区可能会阻止其他应用程序获得保证的 CPU 百分比。

### 中断处理程序

中断处理程序中使用的时间永远不会受到限制。也就是说，我们总是选择执行全局最高优先级的中断处理程序，与其调度器分区无关。这意味着导致过多中断的故障硬件或软件会有效限制其他应用程序的可用时间。

中断线程（例如，使用 InterruptAttachEvent() 的线程）所花费的时间正确计入这些线程的分区。

