# 持久化发布/订阅开发指南

​	QNX Neutrino PPS开发手册描述了如何使用**PPS(Persistent Publish Subscribe)**在进程间以灵活的方式传递数据，从而在系统重启时保留信息。一下链接将帮助你找到你所需要的内容

| 内容                                         | 章节                 |
| -------------------------------------------- | -------------------- |
| 介绍PPS服务以及如何运行                      | QNX Neutrino PPS服务 |
| PPS服务对象及其属性介绍                      | 对象及其属性         |
| PPS如何管理持久化                            | 持久化               |
| 如何发布到PPS                                | 发布                 |
| 如何从PPS订阅                                | 订阅                 |
| 如何使用PPS服务对象                          | 使用服务对象工作     |
| 路径打开选项与对象及属性限定                 | 选线与限定符         |
| 公开可见的PPS编码和解码API函数和数据类型描述 | PPS编解码API         |
| 发布订阅示例                                 | 示例                 |



## QNX Neutrino PPS服务

### 运行PPS

 	PPS服务可以从命令行运行，配以如下的选项

**语法**

```shell
pps [options]
# 选项说明
-A path 指定ACL配置文件路径，可指定多个, 如果权限相互矛盾,则以最后列出的配置文件中的权限为准
-a num  指定所有对象可以打开的最大文件句柄数, 默认最小值为32
-b      前台运行
-C 		在root与非root持久格式之间转换，对应选项为-U
-D dir  指定放置core文件的目录, 默认无
-d backlog  指定默认log增量, 以kb为单位, 默认值为256字节
-l argument 设置对象的加载行为, 说明如下
    0 - 按需加载目录名与对象, 此为默认值
    1 - 启动时加载所有目录与对象名, 但不加载对象内容. 按需加载对象内容
    2 - 启动时加载目录, 对象, 以及对象内容
    
 -m mount     指定PPS挂载路径, 默认为 /pps/
 -P priority  指定持久化线程优先级, 默认10
 -p path      设置持久化存储备份路径, 默认 /var/pps
 -T tolerance 周期持久化刷新间隔公差, 以毫秒为单位, 默认关闭
 -t period    指定强制持久化周期, 单位毫秒, 默认不强制
 -U uid[:gid[,sup_gid]*] 以指定用户(可选组)的身份运行
 -v 开启详细模式, 增加'v'的数量可增加详细程度
```



## 对象及其属性

​	QNX Neutrino PPS服务是一个多个对象的系统, 发布者可以修改这些对象属性。客户端订阅一个对象，当对象改变(即发布者修改了对象)时，客户端接收对象的更新

 	使用PPS，你的应用可进行如下操作

- 发布更改到对象
- 订阅对象从而接收变更通知
- 同时发布与订阅



### 对象文件

​	PPS对象以文件形式实现于一个特殊的PPS文件系统中。默认情况下， PPS对象位于**/pps**目录下, 但该路径可在你运行**pps**时，通过指定**-m**选项改变该路径。PPS对象实例有且只有一个，这样该对象的变更对所有订阅者是立马可见的。

​	一个对象包含多个属性。每个属性由对象文件中的一行文本表示。因此，例如你可能发布一个称为Time的对象，该对象代表一天的时间，并且拥有代表前期小时、分钟、秒的属性如下：

```shell
@Time
hour::17
minute::04
second::38
```

​	在这个例子中, 文件名为Time, 每个属性是该文件中的一个文本字符串。

因为PPS对象以文件形式表示，所以你能对其进行如下操作

- 创建目录并通过创建PPS对象文件来填充目录

  Note: 为了创建对象，你需要拥有PPS目录或者相应子目录的写权限

- 使用open()，然后read()，write()函数来查询并修改PPS对象

- 使用标准实用程序作为简单的调试工具

Note: 为了避免来自不同组织的应用被集成以使用相同的PPS文件系统从而带来的困惑或冲突，我们建议你使用你们组织的web域名在PPS目录中创建你的目录。因此，QNX Software Systems，其web域名为qnx.com，应该使用 **/pps/qnx**，然后域名为example.net的组织应该使用 **/pps/example**

Warn: PPS对象通过文件系统访问，类似普通的POSIX文件。然后，它们并不是标准的POSIX文件，并且一些PPS的行为不同于标准POSIX。例如，如果read缓冲区分配太小不足以数据被读取，read并不会返回部分结果，而是失败。

**属性顺序**

PPS并不保证属性将以它们被写入文件中的顺序被读取。也就是说，一个发布者可能写入如下：

```shell
@Time
hour::17
minute::04
second::38
```

一个订阅者可能读取顺序如下：

```shell
@Time
second::38
hour::17
minute::04
```

#### 特殊对象

PPS目录可以包含特殊对象，你可以打开以促进订阅行为。以下表格列出了这些特殊对象：

| 对象        | 用处                                    |
| ----------- | --------------------------------------- |
| **.all**    | 打开用于接收目录下任何对象的变更通知    |
| **.notify** | 在PPS根文件系统中打开一个通知文件描述符 |



#### 对象和目录大小

​	由于PPS将其对象保存在内存中，因此他们很小。每个对象分配32k空间。这并不意味着每个对象在运行时使用32k内存；它仅使用内部表示其属性所需的内存大小。

​	PPS目录和对象的数量仅仅受可用内存限制。PPS 目录的深度受到以下事实的限制：对象的完整路径名作为文件存储在持久目录中。这些路径名大小被持久化文件系统所使用的最大文件名大小限制。

Note:

- PPSd对象不应用作大量数据的垃圾场。大多数PPS对象的大小应以数百字节为单位，而不是以千字节为单位。
- 使用默认PPS选项下，PPS 已通过电源安全文件系统(**fs-qnx6.so**)进行测试。该配置支持路径名总长517字节，且单个路径名不超过508字节。也就是说，如果路径总长度小于 517 字节，则 fs-qnx6.so 上的嵌套深度可以为 50。



### 修改通知

​	当一个对象被创建、删除或截断时，PPS通知发布者和订阅者。

​	当PPS创建、删除或截断一个对象(一个文件或目录)，它将向任何打开该对象的订阅者或发布者或者**.all**特殊对象的队列中放置一条通知字符串。

​	通知字符串有一个特殊字符前缀，紧接着是对象标识符**@**符号，然后是对象名，说明如下：

| 前缀 | 示例         | 说明                                                     |
| ---- | ------------ | -------------------------------------------------------- |
| +    | +@objectname | PPS创建对象。向知道对象是文件或目录，调用stat()或fstat() |
| -    | -@objectname | PPS删除对象                                              |
| #    | #@objectname | PPS截断对象                                              |
| *    | *@objectname | 对象失去关键发布者。所有非持久化属性已经被删除           |

此外，当对象被删除，PPS发送一个单独的**-@objectname**给所有打开该对象的应用。应用收到该通知的常见行为是关闭打开的文件描述符，因为该文件在文件系统中已经不可见了。

Note: 属性选项始终位于特殊字符和对象或属性名称之前。



### 对象语法

​	在 PPS 文件系统的列表中，PPS 对象没有特殊标识符。也就是说，它们如同其他文件一样出现在列表中。例如，PPS对象**PlayCurrent**在目录**/pps/media**中显示为**/pps/media/PlayCurrent**

​	在读取PPS文件的结果中，第一行标识该对象。该行是在对象名之前以**@**符号为前缀。该行之后定义对象的属性。这些行没有特殊的前缀。

​	假设PPS对象**PlayCurrent**包含了描述多媒体应用中当前播放歌曲的元数据的相关属性。我们假设属性有如下格式：

```shell
@PlayCurrent
author::[Presentation text for track author]
album::[Presentation text for album name]
title::[Presentation text for track title]
duration::[Track duration, floating point number of seconds]
time::[Track position, floating point number of seconds]
```

一个在该对象上执行open()调用，紧接着read()调用，将得到对象的名称(文件名, 以@为前缀)，然后紧接着的是对象属性与属性值：

```shell
@PlayCurrent
author::Beatles
album::Abbey Road
title::Come Together
duration::3.45
time::1.24
```

Note:

- 对象名不能包含以下任何字符：@  ?  /  换行符  ASCII NUL
- PPS对象每行以换行符结束，因此，您必须以协作客户端应用程序同意的方式对该字符进行编码。也就是说，任何包含ASCII LF或NUL字符的值都必须被编码。编码字段可用于帮助协作应用程序确定在value字段中使用什么编码。



### 属性语法

​	PPS对象拥有用户定义的属性。在一个PPS对象中属性列于对象名之后。

​	属性名称可以由字母数字字符、下划线和句点组成，但必须以字母或下划线开头。在PPS对象文件中，属性行的格式如下：

```
attrname:encoding:value\n
```

attrname表示属性名，encoding定义了value的编码类型。属性名结尾与编码结尾已冒号**:**标记。后续冒号将被忽略。

​	PPS并不翻译编码；它仅仅将编码从发布者传递给订阅者。因此，发布者和订阅者可以自由定义它们的编码方式以满足自身需求。如下表格描述了可能得编码类型：

| 符号   | 编码                         |
| ------ | ---------------------------- |
| : :    | 编码为空。普通文本以换行终止 |
| : c :  | C语言转移序列，例如\t \n     |
| : b :  | 布尔类型                     |
| :n:    | 数字                         |
| :b64:  | Base64编码                   |
| :json: | Json编码                     |

一个属性的值可以是字符的任意序列，除了：

- 空字符，C语言中的'\0'，十六进制为0x00
- 换行符，C语言中为'\n'，十六进制为0x0A

PPS 包括一些有用的方法来帮助编码；请参考**PPS编解码API**和**PPS API手册**章节。



## 持久化

PPS运行时，其在内存中维护它的对象。其要求如下：

- 将其对象保存在持久存储中，无论是在运行时按需还是在关闭时
- 在启动时立即或首次访问(延迟加载)时恢复其对象



Note:

- PPS可用于创建很少(或从不)被发布或订阅但需要持久化的对象。
- "Shutdown"是指PPS服务进程有序退出。有序退出可以被**SIGTERM，SIGINT，或SIGQUIT**信号触发。由于其他信号(例如SIGKILL，SIGSEGV和SIGABRT)不会导致有序退出，它们并不构成以持久化为目的的关闭



### 持久化存储

​	PPS支持跨重启的持久存储。该存储需要一个可靠的文件系统。

​	PPS的底层持久化存储依赖可靠的文件系统，例如：

- 硬盘 - 电源安全的文件系统
- NAND闪存 - ETFS文件系统
- Nor闪存 - FFS3文件系统
- 其他 - 客户生成的文件系统

​	如果你想持久化一个对象到特殊的硬件例如小型NVRAM(其不支持文件系统)，你可以你自己的客户端来订阅被保存的PPS对象。当每个对象改变时，PPS将通知客户端，允许客户端实时更新NVRAM

**持久化与文件系统限制**

​	存储PPS对象的持久化目录与PPS根目录具有完全相同的目录层次结构。因此对象持久化受路径与文件名长度限制如同嵌套目录受底层文件系统限制一样。

​	例如，NQX Neutrino NFS服务器支持最大为15的嵌套深度。这个限制也应用到了使用该服务的PPS上。



### 保存对象

​	当关机时，PPS总是将任何修改过的对象保存在持久化文件系统中。你也可以在对象上通过调用**fsync()**在任何时间保存一个对象。

​	当PPS保存其数据到持久化文件系统时，它将每个对象保存在其自己的文件中，其目录层次结构体现了PPS对象树的层次结构。例如，默认配置下，PPS对象**/pps/example/object1**存储在**/var/pps/example/object1**

​	PPS目录的默认位置是**/var/pps**。你可以使用PPS **-p**选项修改该位置。

Note:

- 编辑PPS文件的持久化版本是可行的。如果安全对你的系统很重要，你应该让PPS将数据保存到一个加密的文件系统
- 你可以设置对象和属性限定符从而让PPS不存储特殊对象或属性



**修改持久化存储目录**

PPS对象树根目录(默认为**/pps**)下看起来如下所示：

```shell
# pwd
/pps
# ls -1F
accounts/
applications/
qnx/
qnxcar/
servicedata/
services/
system/
#
```



​	PPS从持久化树(默认为**/var/pps**)生成根对象树，该根对象树保存你想要持久化的对象和属性。

​	为指定持久化到不同目录：

1. 创建你自己的持久化目录(例如 mkdir /myobjects)

2. 从一个不同的挂载点(例如**/fs/pps**)启动PPS服务并指定你的新持久化目录：

   ```shell
   pps -m /fs/pps -p /myobjects
   ```

Note:

​	你也许想使用**-t**选项来启动PPS，该选项指定了PPS写入持久存储的间隔。没有**-t**，你将不能看到持久化目录中的任何改变直到PPS退出。更多信息请查看**运行PPS**章节。



### 加载对象

​	当PPS启动时，它将从持久化文件系统中被编码的文件名创建目录层次结构。

​	默认配置中，PPS直到第一次访问这些文件中的一个时延迟加载目录中的对象。该访问操作可以是在一个PPS对象上的**open()**调用或者PPS目录上的**readdir()**调用。

​	你可以在启动PPS时通过提供**-l**选项来修改改配置，从而达到一下目的：

- 加载目录和对象名(不包含对象内容)
- 加载目录、对象和对象内容

更多信息，请查看**运行PPS**章节



## 发布

​	为了发布一个PPS对象， 发布者可以仅仅调用**open()**，使用带**O_WRONLY**标识打开对象文件来发布，带**O_RDWR**标识来发布并订阅。发布者调用**write()**来修改对象属性，该操作是非阻塞的。

​	简单的示例，请查看示例附录中的**发布者**章节。

​	当你向文件写入一个属性时，只需一个操作即可完成。需要对对象进行一次 write() 来保证可以正确处理来自多个发布者的同时写入。例如，不是如下这类形式

```c
write( fd, "state::", 7);
if ( state == 0 )
   write( fd, "off", 3);
else
   write( fd, "on", 2);
```

而是以下这种形式(即只需一次write调用)

```c
snprintf( buf, sizeof(buf), "state::%s", state ? "on" : "off");
write( fd, buf, strlen(buf) );
```



### 创建修改删除对象和属性

你可以创建、修改和删除对象与属性，操作如下

| 目的               | 操作                                                         |
| ------------------ | ------------------------------------------------------------ |
| 创建一个新对象     | 创建一个对象名称的文件。新的对象将没有属性，之后你可以写入属性到该对象中 |
| 删除一个对象       | 删除对象文件                                                 |
| 创建一个新属性     | 写入属性到对象文件中                                         |
| 修改属性           | 写入新的属性值到对象文件中。无需lseek()调用来定位到文件中属性的位置，对PPS而言seek没有效果。 |
| 删除所有存在的属性 | 以**O_TRUNC**标识打开一个对象                                |
| 删除一个属性       | 在属性名前加上**-**减号符号，然后调用**write()**，例如       |
|                    | // Delete the "url" attribute<br/>sprintf( ppsobj, "-url\n" ); <br/>write( ppsobj-fd, ppsobj, strlen( ppsobj ) ); |



Note: 删除属性时请注意如下

- 在对象文件上调用**ftruncate()**将删除所有对象属性，无论值的长度为多少
- 在bash中的重定向指令(如 echo attr::hello > /pps/object)将使用**O_TRUNC**标识打开对象并删除所有属性。



### 多个发布者

​	PPS支持多个发布者发布相同的PPS对象。需要此功能是因为不同的发布者可能有权访问适用于同一对象的不同属性的数据。

Note: 超过一个发布者写一个对象是安全的，因为pps管理器保证每一个PPS **write()**操作是原子的。

​	例如，在一个拥有PlayCurrent对象的多媒体系统中，**io-media**可能是time::value属性的来源，同时HMI可能是duration::value的来源。一个发布者仅仅修改time属性将仅仅更新该属性当它写入对象时。其他对象属性将不会被改变。

​	在上面的例子中，假设PlayCurrent对象有如下属性值：

```
@PlayCurrent
author::Beatles
album::Abbey Road
title::Come Together
duration::3.45
time::1.24
```

如果 **io-media** 更新PlayCurrent对象的time属性如下：

```c
// Update the "time" attribute
sprintf( ppsobj, "time::2.32\n" );
write( ppsobj-fd, ppsobj, strlen( ppsobj ) );
```

并且HMI更新duration属性如下：

```
// Update the "duration" attribute
sprintf( ppsobj, "duration::4.02\n" );
write( ppsobj-fd, ppsobj, strlen( ppsobj ) );
```

结果将如下：

```
@PlayCurrent
author::Beatles
album::Abbey Road
title::Come Together
duration::4.02
time::2.32
```

其他示例，请查看示例附录中的发布者章节









