# 持久化发布/订阅开发指南

​	QNX Neutrino PPS开发手册描述了如何使用**PPS(Persistent Publish Subscribe)**在进程间以灵活的方式传递数据，从而在系统重启时保留信息。一下链接将帮助你找到你所需要的内容

| 内容                                         | 章节                 |
| -------------------------------------------- | -------------------- |
| 介绍PPS服务以及如何运行                      | QNX Neutrino PPS服务 |
| PPS服务对象及其属性介绍                      | 对象及其属性         |
| PPS如何管理持久化                            | 持久化               |
| 如何发布到PPS                                | 发布                 |
| 如何从PPS订阅                                | 订阅                 |
| 如何使用PPS服务对象                          | 使用服务对象工作     |
| 路径打开选项与对象及属性限定                 | 选线与限定符         |
| 公开可见的PPS编码和解码API函数和数据类型描述 | PPS编解码API         |
| 发布订阅示例                                 | 示例                 |



## QNX Neutrino PPS服务

### 运行PPS

 	PPS服务可以从命令行运行，配以如下的选项

**语法**

```shell
pps [options]
# 选项说明
-A path 指定ACL配置文件路径，可指定多个, 如果权限相互矛盾,则以最后列出的配置文件中的权限为准
-a num  指定所有对象可以打开的最大文件句柄数, 默认最小值为32
-b      前台运行
-C 		在root与非root持久格式之间转换，对应选项为-U
-D dir  指定放置core文件的目录, 默认无
-d backlog  指定默认log增量, 以kb为单位, 默认值为256字节
-l argument 设置对象的加载行为, 说明如下
    0 - 按需加载目录名与对象, 此为默认值
    1 - 启动时加载所有目录与对象名, 但不加载对象内容. 按需加载对象内容
    2 - 启动时加载目录, 对象, 以及对象内容
    
 -m mount     指定PPS挂载路径, 默认为 /pps/
 -P priority  指定持久化线程优先级, 默认10
 -p path      设置持久化存储备份路径, 默认 /var/pps
 -T tolerance 周期持久化刷新间隔公差, 以毫秒为单位, 默认关闭
 -t period    指定强制持久化周期, 单位毫秒, 默认不强制
 -U uid[:gid[,sup_gid]*] 以指定用户(可选组)的身份运行
 -v 开启详细模式, 增加'v'的数量可增加详细程度
```



## 对象及其属性

​	QNX Neutrino PPS服务是一个多个对象的系统, 发布者可以修改这些对象属性。客户端订阅一个对象，当对象改变(即发布者修改了对象)时，客户端接收对象的更新

 	使用PPS，你的应用可进行如下操作

- 发布更改到对象
- 订阅对象从而接收变更通知
- 同时发布与订阅



### 对象文件

​	PPS对象以文件形式实现于一个特殊的PPS文件系统中。默认情况下， PPS对象位于**/pps**目录下, 但该路径可在你运行**pps**时，通过指定**-m**选项改变该路径。PPS对象实例有且只有一个，这样该对象的变更对所有订阅者是立马可见的。

​	一个对象包含多个属性。每个属性由对象文件中的一行文本表示。因此，例如你可能发布一个称为Time的对象，该对象代表一天的时间，并且拥有代表前期小时、分钟、秒的属性如下：

```shell
@Time
hour::17
minute::04
second::38
```

​	在这个例子中, 文件名为Time, 每个属性是该文件中的一个文本字符串。

因为PPS对象以文件形式表示，所以你能对其进行如下操作

- 创建目录并通过创建PPS对象文件来填充目录

  Note: 为了创建对象，你需要拥有PPS目录或者相应子目录的写权限

- 使用open()，然后read()，write()函数来查询并修改PPS对象

- 使用标准实用程序作为简单的调试工具

Note: 为了避免来自不同组织的应用被集成以使用相同的PPS文件系统从而带来的困惑或冲突，我们建议你使用你们组织的web域名在PPS目录中创建你的目录。因此，QNX Software Systems，其web域名为qnx.com，应该使用 **/pps/qnx**，然后域名为example.net的组织应该使用 **/pps/example**

Warn: PPS对象通过文件系统访问，类似普通的POSIX文件。然后，它们并不是标准的POSIX文件，并且一些PPS的行为不同于标准POSIX。例如，如果read缓冲区分配太小不足以数据被读取，read并不会返回部分结果，而是失败。

**属性顺序**

PPS并不保证属性将以它们被写入文件中的顺序被读取。也就是说，一个发布者可能写入如下：

```shell
@Time
hour::17
minute::04
second::38
```

一个订阅者可能读取顺序如下：

```shell
@Time
second::38
hour::17
minute::04
```

#### 特殊对象

PPS目录可以包含特殊对象，你可以打开以促进订阅行为。以下表格列出了这些特殊对象：

| 对象        | 用处                                    |
| ----------- | --------------------------------------- |
| **.all**    | 打开用于接收目录下任何对象的变更通知    |
| **.notify** | 在PPS根文件系统中打开一个通知文件描述符 |



#### 对象和目录大小

​	由于PPS将其对象保存在内存中，因此他们很小。每个对象分配32k空间。这并不意味着每个对象在运行时使用32k内存；它仅使用内部表示其属性所需的内存大小。

​	PPS目录和对象的数量仅仅受可用内存限制。PPS 目录的深度受到以下事实的限制：对象的完整路径名作为文件存储在持久目录中。这些路径名大小被持久化文件系统所使用的最大文件名大小限制。

Note:

- PPSd对象不应用作大量数据的垃圾场。大多数PPS对象的大小应以数百字节为单位，而不是以千字节为单位。
- 使用默认PPS选项下，PPS 已通过电源安全文件系统(**fs-qnx6.so**)进行测试。该配置支持路径名总长517字节，且单个路径名不超过508字节。也就是说，如果路径总长度小于 517 字节，则 fs-qnx6.so 上的嵌套深度可以为 50。



### 修改通知

​	当一个对象被创建、删除或截断时，PPS通知发布者和订阅者。

​	当PPS创建、删除或截断一个对象(一个文件或目录)，它将向任何打开该对象的订阅者或发布者或者**.all**特殊对象的队列中放置一条通知字符串。

​	通知字符串有一个特殊字符前缀，紧接着是对象标识符**@**符号，然后是对象名，说明如下：

| 前缀 | 示例         | 说明                                                     |
| ---- | ------------ | -------------------------------------------------------- |
| +    | +@objectname | PPS创建对象。向知道对象是文件或目录，调用stat()或fstat() |
| -    | -@objectname | PPS删除对象                                              |
| #    | #@objectname | PPS截断对象                                              |
| *    | *@objectname | 对象失去关键发布者。所有非持久化属性已经被删除           |

此外，当对象被删除，PPS发送一个单独的**-@objectname**给所有打开该对象的应用。应用收到该通知的常见行为是关闭打开的文件描述符，因为该文件在文件系统中已经不可见了。

Note: 属性选项始终位于特殊字符和对象或属性名称之前。



### 对象语法

​	在 PPS 文件系统的列表中，PPS 对象没有特殊标识符。也就是说，它们如同其他文件一样出现在列表中。例如，PPS对象**PlayCurrent**在目录**/pps/media**中显示为**/pps/media/PlayCurrent**

​	在读取PPS文件的结果中，第一行标识该对象。该行是在对象名之前以**@**符号为前缀。该行之后定义对象的属性。这些行没有特殊的前缀。

​	假设PPS对象**PlayCurrent**包含了描述多媒体应用中当前播放歌曲的元数据的相关属性。我们假设属性有如下格式：

```shell
@PlayCurrent
author::[Presentation text for track author]
album::[Presentation text for album name]
title::[Presentation text for track title]
duration::[Track duration, floating point number of seconds]
time::[Track position, floating point number of seconds]
```

一个在该对象上执行open()调用，紧接着read()调用，将得到对象的名称(文件名, 以@为前缀)，然后紧接着的是对象属性与属性值：

```shell
@PlayCurrent
author::Beatles
album::Abbey Road
title::Come Together
duration::3.45
time::1.24
```

Note:

- 对象名不能包含以下任何字符：@  ?  /  换行符  ASCII NUL
- PPS对象每行以换行符结束，因此，您必须以协作客户端应用程序同意的方式对该字符进行编码。也就是说，任何包含ASCII LF或NUL字符的值都必须被编码。编码字段可用于帮助协作应用程序确定在value字段中使用什么编码。



### 属性语法

​	PPS对象拥有用户定义的属性。在一个PPS对象中属性列于对象名之后。

​	属性名称可以由字母数字字符、下划线和句点组成，但必须以字母或下划线开头。在PPS对象文件中，属性行的格式如下：

```
attrname:encoding:value\n
```

attrname表示属性名，encoding定义了value的编码类型。属性名结尾与编码结尾已冒号**:**标记。后续冒号将被忽略。

​	PPS并不翻译编码；它仅仅将编码从发布者传递给订阅者。因此，发布者和订阅者可以自由定义它们的编码方式以满足自身需求。如下表格描述了可能得编码类型：

| 符号   | 编码                         |
| ------ | ---------------------------- |
| : :    | 编码为空。普通文本以换行终止 |
| : c :  | C语言转移序列，例如\t \n     |
| : b :  | 布尔类型                     |
| :n:    | 数字                         |
| :b64:  | Base64编码                   |
| :json: | Json编码                     |

一个属性的值可以是字符的任意序列，除了：

- 空字符，C语言中的'\0'，十六进制为0x00
- 换行符，C语言中为'\n'，十六进制为0x0A

PPS 包括一些有用的方法来帮助编码；请参考**PPS编解码API**和**PPS API手册**章节。



## 持久化

PPS运行时，其在内存中维护它的对象。其要求如下：

- 将其对象保存在持久存储中，无论是在运行时按需还是在关闭时
- 在启动时立即或首次访问(延迟加载)时恢复其对象



Note:

- PPS可用于创建很少(或从不)被发布或订阅但需要持久化的对象。
- "Shutdown"是指PPS服务进程有序退出。有序退出可以被**SIGTERM，SIGINT，或SIGQUIT**信号触发。由于其他信号(例如SIGKILL，SIGSEGV和SIGABRT)不会导致有序退出，它们并不构成以持久化为目的的关闭



### 持久化存储

​	PPS支持跨重启的持久存储。该存储需要一个可靠的文件系统。

​	PPS的底层持久化存储依赖可靠的文件系统，例如：

- 硬盘 - 电源安全的文件系统
- NAND闪存 - ETFS文件系统
- Nor闪存 - FFS3文件系统
- 其他 - 客户生成的文件系统

​	如果你想持久化一个对象到特殊的硬件例如小型NVRAM(其不支持文件系统)，你可以你自己的客户端来订阅被保存的PPS对象。当每个对象改变时，PPS将通知客户端，允许客户端实时更新NVRAM

**持久化与文件系统限制**

​	存储PPS对象的持久化目录与PPS根目录具有完全相同的目录层次结构。因此对象持久化受路径与文件名长度限制如同嵌套目录受底层文件系统限制一样。

​	例如，NQX Neutrino NFS服务器支持最大为15的嵌套深度。这个限制也应用到了使用该服务的PPS上。



### 保存对象

​	当关机时，PPS总是将任何修改过的对象保存在持久化文件系统中。你也可以在对象上通过调用**fsync()**在任何时间保存一个对象。

​	当PPS保存其数据到持久化文件系统时，它将每个对象保存在其自己的文件中，其目录层次结构体现了PPS对象树的层次结构。例如，默认配置下，PPS对象**/pps/example/object1**存储在**/var/pps/example/object1**

​	PPS目录的默认位置是**/var/pps**。你可以使用PPS **-p**选项修改该位置。

Note:

- 编辑PPS文件的持久化版本是可行的。如果安全对你的系统很重要，你应该让PPS将数据保存到一个加密的文件系统
- 你可以设置对象和属性限定符从而让PPS不存储特殊对象或属性



**修改持久化存储目录**

PPS对象树根目录(默认为**/pps**)下看起来如下所示：

```shell
# pwd
/pps
# ls -1F
accounts/
applications/
qnx/
qnxcar/
servicedata/
services/
system/
#
```



​	PPS从持久化树(默认为**/var/pps**)生成根对象树，该根对象树保存你想要持久化的对象和属性。

​	为指定持久化到不同目录：

1. 创建你自己的持久化目录(例如 mkdir /myobjects)

2. 从一个不同的挂载点(例如**/fs/pps**)启动PPS服务并指定你的新持久化目录：

   ```shell
   pps -m /fs/pps -p /myobjects
   ```

Note:

​	你也许想使用**-t**选项来启动PPS，该选项指定了PPS写入持久存储的间隔。没有**-t**，你将不能看到持久化目录中的任何改变直到PPS退出。更多信息请查看**运行PPS**章节。



### 加载对象

​	当PPS启动时，它将从持久化文件系统中被编码的文件名创建目录层次结构。

​	默认配置中，PPS直到第一次访问这些文件中的一个时延迟加载目录中的对象。该访问操作可以是在一个PPS对象上的**open()**调用或者PPS目录上的**readdir()**调用。

​	你可以在启动PPS时通过提供**-l**选项来修改改配置，从而达到一下目的：

- 加载目录和对象名(不包含对象内容)
- 加载目录、对象和对象内容

更多信息，请查看**运行PPS**章节



## 发布

​	为了发布一个PPS对象， 发布者可以仅仅调用**open()**，使用带**O_WRONLY**标识打开对象文件来发布，带**O_RDWR**标识来发布并订阅。发布者调用**write()**来修改对象属性，该操作是非阻塞的。

​	简单的示例，请查看示例附录中的**发布者**章节。

​	当你向文件写入一个属性时，只需一个操作即可完成。需要对对象进行一次 write() 来保证可以正确处理来自多个发布者的同时写入。例如，不是如下这类形式

```c
write( fd, "state::", 7);
if ( state == 0 )
   write( fd, "off", 3);
else
   write( fd, "on", 2);
```

而是以下这种形式(即只需一次write调用)

```c
snprintf( buf, sizeof(buf), "state::%s", state ? "on" : "off");
write( fd, buf, strlen(buf) );
```



### 创建修改删除对象和属性

你可以创建、修改和删除对象与属性，操作如下

| 目的               | 操作                                                         |
| ------------------ | ------------------------------------------------------------ |
| 创建一个新对象     | 创建一个对象名称的文件。新的对象将没有属性，之后你可以写入属性到该对象中 |
| 删除一个对象       | 删除对象文件                                                 |
| 创建一个新属性     | 写入属性到对象文件中                                         |
| 修改属性           | 写入新的属性值到对象文件中。无需lseek()调用来定位到文件中属性的位置，对PPS而言seek没有效果。 |
| 删除所有存在的属性 | 以**O_TRUNC**标识打开一个对象                                |
| 删除一个属性       | 在属性名前加上**-**减号符号，然后调用**write()**，例如       |
|                    | // Delete the "url" attribute<br/>sprintf( ppsobj, "-url\n" ); <br/>write( ppsobj-fd, ppsobj, strlen( ppsobj ) ); |



Note: 删除属性时请注意如下

- 在对象文件上调用**ftruncate()**将删除所有对象属性，无论值的长度为多少
- 在bash中的重定向指令(如 echo attr::hello > /pps/object)将使用**O_TRUNC**标识打开对象并删除所有属性。



### 多个发布者

​	PPS支持多个发布者发布相同的PPS对象。需要此功能是因为不同的发布者可能有权访问适用于同一对象的不同属性的数据。

Note: 超过一个发布者写一个对象是安全的，因为pps管理器保证每一个PPS **write()**操作是原子的。

​	例如，在一个拥有PlayCurrent对象的多媒体系统中，**io-media**可能是time::value属性的来源，同时HMI可能是duration::value的来源。一个发布者仅仅修改time属性将仅仅更新该属性当它写入对象时。其他对象属性将不会被改变。

​	在上面的例子中，假设PlayCurrent对象有如下属性值：

```
@PlayCurrent
author::Beatles
album::Abbey Road
title::Come Together
duration::3.45
time::1.24
```

如果 **io-media** 更新PlayCurrent对象的time属性如下：

```c
// Update the "time" attribute
sprintf( ppsobj, "time::2.32\n" );
write( ppsobj-fd, ppsobj, strlen( ppsobj ) );
```

并且HMI更新duration属性如下：

```
// Update the "duration" attribute
sprintf( ppsobj, "duration::4.02\n" );
write( ppsobj-fd, ppsobj, strlen( ppsobj ) );
```

结果将如下：

```
@PlayCurrent
author::Beatles
album::Abbey Road
title::Come Together
duration::4.02
time::2.32
```

其他示例，请查看示例附录中的发布者章节



## 订阅者

​	PPS客户端能订阅多个对象，并且PPS对象可以有多个订阅者。当一个发布者修改一个对象时，所有订阅过该对象的客户端将被通知变更。

​	为了订阅一个对象，客户端只需简单调用**open()**，以**O_RDONLY**标识表示只订阅，以**O_RDWR**标识表示订阅并发布。订阅者能调用**read()**查询对象。read返回读取数据的长度，单位字节。

Note:

- PPS对每个PPS对象限制200个打开的文件描述符。
- PPS的read行为不同于标准POSIX行为。在PPS中，如果分配的读缓冲区对于要读取的数据太小时，read并不返回部分数据，而是失败

多个订阅者从一个对象读取时安全的，因为pps管理器保证了每一个PPS read()调用是原子的。



**属性顺序**

PPS并不保证属性读取的顺序与写入对象时相同。也就是说，一个发布者可能以如下顺序写入：

```
@Time
hour::17
minute::04
second::38
```

一个订阅者可能以如下顺序读取

```
@Time
second::38
hour::17
minute::04
```



更多相关帮助你解析属性的信息，请查看**PPS编解码API**与**PPS API手册**章节



### 在文件描述符上等待数据

​	通常情况下，为了PPS数据轮询是一个不好的方法。在一个文件描述符上等待速度到达是更好的方式，可使用如下机制：

- 阻塞调用**read()**
- 使用**ionotify()**机制接受你指定的事件
- 使用**select()**函数

​	一个阻塞read()是最简答的方式。通常，如果您想在同一进程中将文件描述符的输入与 QNX Neutrino 消息传递结合起来，则可以使用 ionotify()。当你需要处理多个文件描述符，这些描述符来自socket、pipe、串口等等时，使用select()。这些机制将在下面描述。示例请查看示例附录中的订阅者相关章节。

Warn: 

​	默认，读取一个PPS对象是非阻塞的；也就是说，PPS调用open()时默认了O_NONBLOCK，因此客户端打开对象的读取操作将不会阻塞。该行为不同于大多数文件系统。这样处理的原因在于对于一些标准实用程序当它们在一个文件上读取时不会被挂起等待变更的到来。例如，默认行为下，你可以调用**tar**打包整个PPS的状态。没有该行为，**tar**将永远服务越过第一个打开和读取的文件(即tar将会阻塞在第一个open()或read()的文件处，无法向下继续执行)。



**使用阻塞方式读取**

​	一个阻塞的**read()**会一直等待直到对象或其属性变更，并且然后返回数据。为了使读取阻塞，你需要打开对象时带上**?wait**在路径名中，附加在对象路径名作为后缀。例如，为了打开**PlayList**对象

- 默认非阻塞读取，使用路径名："/pps/media/PlayList"
- 阻塞读取，使用路径名加上选项："/pps/media/PlayList?wait"

更多关于**?wait**的信息，请查看**路径打开选项**章节。

通常订阅者自己的线程中存在一个循环。对于一个以**?wait**选项打开对象的订阅者而言，该循环可能操作如下：

```c
/* Assume that the object was opened with the ?wait option
   No error checking in this example. */
for(;;) {
    read(fd, buf, sizeof(buf)); // Read waits until the object changes.
    process(buf);
}
```

如果你打开一个对象没有**?wait**选项并且想修改为阻塞读，你可以使用**fcntl()**清除O_NONBLOCK比特位

```c
flags = fcntl(fd, F_GETFL);
flags &= ~O_NONBLOCK;
fcntl(fd, F_SETFL, flags);
```

或者通过**ioctl()**

```c
int i=0;
ioctl(fd,FIONBIO,&i);
```



**使用ionotify()**

PPS服务实现了**ionotify()**功能，允许订阅者通过pulse、signal、semaphore等请求通知。当一个变更通知抵达时，你必须调用read()从对象文件读取对象内容。例如：

```c
/* Process events while there are some */
while ( ( flags = ionotify( fd, _NOTIFY_ACTION_POLLARM, 
                            _NOTIFY_COND_INPUT, event ) != -1 )
          && (flags & _NOTIFY_COND_INPUT) )
{
    nbytes = read(fd, buf, sizeof(buf));
    if ( nbytes > 0 )
        process(buf);
}
/* If flags != -1, the event will be triggered in the future to get
   our attention */
```



**使用select()**

select()函数测试一系列文件描述符，看是否他们是可读或可写。为了将select()与PPS一起使用，设置fd_set使其包含PPS对象的文件描述符。你可以选择性的设置一个时间限制。例如：

```c
FD_ZERO( &readfds );
FD_SET( fd, &readfds );

switch ( ret = select( fd + 1, &readfds, NULL, NULL, &timeout ) )
{
   case -1:
      /* An error occurred. */
      break;
   case  0:
      /* select() timed out. */
      break;
   default:
      if( FD_ISSET( fd, &readfds ) )
      {
         num_bytes = read( fd, buf, sizeof(buf) );
         if (num_bytes > 0)
            process(buf);
      }
}
```



更多信息，请查看**select()**的C语言库手册。



### 订阅模式

​	订阅者可以以完整模式、增量模式或同时以完整模式和增量模式打开对象。**默认为完整模式**。为了以增量模式打开文件对象，需在对象路径名上追加打开选项**?delta**后缀。

#### 完整模式

​	在完整模式中，当订阅者请求时，它总是收到整个对象的单个一致版本。如果一个发布者在订阅者请求之间多次修改一个对象，订阅者将仅仅能收到本次请求时的对象状态。如果对象再次更新，订阅者将再次收到更新通知。因此，在完整模式中，订阅者可能丢失一个对象的多次更新 (这些对象的更新发生在订阅者请求对象之前)。

#### 增量模式

​	在增量模式中，订阅者接收仅仅只是对象属性的变更(但是所有的变更)。

​	在第一次读取时，因为订阅者对对象状态一无所知，PPS假设一切都改变了。因而，订阅者的初次增量模式读取将返回对象的所有属性。而后续读取仅返回自该订阅者上次读取以来的更改。

​	因此，在增量模式中，订阅者总是接收对象的所有更改。

​	在所有的模式中，PPS始终维持持久化对象和其状态。对象的打开模式不会修改对象；它仅仅决定了订阅者能看到的对象更新的视图。

**增量模式队列**

当一个订阅者以增量模式打开一个对象时，PPS创建一个对象变更的新队列。也就是说，如果多个订阅者以增量模式打开对象，每一个订阅者将拥有它们自己的对象变更队列，并且PPS服务将它自身的更新拷贝发送给每个订阅者。如果没有订阅制以增量模式打开对象，PPS服务不会维护该对象的任何变更队列。

Note: 当关机时，PPS服务保存它的对象，但是对象的增量队列被丢弃了

**多个属性的变更**

如果一个订阅者在单个write()调用中修改了多个属性，那么PPS一起保持这些增量并且在订阅者调用read()时以相同的组返回这些更新。换句话说，PPS增量保持了更改的时间和原子性。例如：

```
write()                     write()
  time::1.23                 time::1.24
  duration::4.2             write()
                             duration::4.2

read()                     read()
  @objname                   @objname
  time::1.23                 time:1.24
  duration::4.2              @objname
                             duration::4.2
```



### 订阅多个对象

​	PPS支持多种特殊对象，方便订阅多个对象。

| 打开的特殊对象 | 接收变更通知           |
| -------------- | ---------------------- |
| **.all**       | 目录中的任何对象       |
| **.notify**    | 与通知组关联的任何对象 |



#### 订阅目录中的所有对象

​	PPS 使用目录作为自然分组机制来简化并提高订阅多个对象的任务。你可以通过调用**open()**打开多个对象，然后通过**select()**监听它们的文件描述符。更简单的方式是，你可以打开特殊对象**.all**，该对象合并其目录中的所有对象(即相当于所有对象变更都可通过**.all**接收到)。

​	例如，假设/pps下有如下对象文件结构：

```
rear/left/PlayCurrent
rear/left/Time
rear/left/PlayError
```

​	如果你打开**rear/left/.all**，你将可以接受任何**rear/left**目录下对象的变更通知。在全量模式下一次读取最多将返回一个对象。

```
read()
@Time
  position::18
  duration::300

read()
@PlayCurrent
  artist::The Beatles
  genre::Pop
  ... the full set of attributes for the object
```

如果你以增量模式打开**.all**，然而，你将收到目录下任何对象的每个变更属性的队列。在这种情况下，单次**read()**调用将包含多个对象。

```
read()
@Time
  position::18
@Time
  position::19
@PlayCurrent
  artist::The Beatles
  genre::Pop
```



#### 通知组

​	PPS提供了一种机制将一个文件描述符集合与一个通知组关联起来。这种机制允许你仅仅需要读取PPS特殊通知对象就能接受与通知组关联的任何对象的变更通知。

##### 创建通知组

创建通知组需进行如下操作：

1. 在PPS文件系统根目录打开**.notify**对象
2. 读取**.notify**对象；第一次读取此文件会返回一个短字符串（少于 16 个字符），其中包含其他文件描述符应与其关联的组的名称。

为了将文件描述符与组关联，在open时，特别指定路径的open选项**?notify=group:value**，其中：

- group是首次冲**.notify**文件读取返回的字符串。 
- value时任意字符串，订阅者使用该字符串来判断绑定到通知组上的哪个对象有数据可读。

Note: 返回的通知组字符串是以换行符结尾的，你必须在使用该字符串之前删除它。



##### 使用通知组

​	一旦你创建了通知组并将文件描述符与其关联，您可以使用该组来了解与其关联的任何对象的更改。只要任何组的文件描述符上有数据可供读取，读取通知对象的文件描述符就会返回在 ?notify=group:value 路径名选项中传递的字符串。

例如，将PPS挂载在**/pps**，你可以写入如下内容

```c
char noid[16], buf[128];
int notify_fd, fd1, fd2;

notify_fd = open("/pps/.notify", O_RDONLY);
read(notify_fd, &noid[0], sizeof(noid));

sprintf(buf, "/pps/fish?notify=%s:water", noid);
fd1 = open(buf, O_RDONLY);
sprintf(buf, "/pps/dir/birds?notify=%s:air", noid);
fd2 = open(buf, O_RDONLY);

while(read(notify_fd, &buf, sizeof(buf) > 0) {
    printf("Notify %s\n", buf);
}
```

上面例子中在while循环中打印的内容可能如下：

```
Notify 243:water
Notify 243:water
Notify 243:air
Notify 243:water
Notify 243:air
```



Note: 当从一个绑定了通知组的对象读取时，订阅者应该对指示的每个更改进行多次读取。一个项可能有多个更改，但不能保证每个更改都会在通知组的文件描述符上指示。



**关闭对象文件描述符的通知**

​	如果一个通知组中对象的文件描述符被关闭，变更通知字符串将以 减号 **-**  为前缀。例如：

```
-243:air
```



## 选项与限定符

​	PPS 允许您在打开对象时使用各种路径名选项。PPS 使用这些路径名选项在用于打开对象的文件描述符上应用打开选项。

​	PPS 还允许您使用限定符来指定对对象或属性采取的操作(例如，使对象变为非持久或删除属性)。

### 路径名打开选项

​	PPS对象支持在路径名上的扩展语法用于打开它们。

​	打开选项作为后缀添加到路径名中，紧跟着问号**?**。也就是说，PPS服务将任何路径名中问号之后的数据应用到文件描述的打开选项，从而访问对象。多个选项以**逗号**分隔。例如：

| 路径名                         | 说明                              |
| ------------------------------ | --------------------------------- |
| /pps/media/PlayList            | 以无选项打开**PlayList**          |
| /pps/media/PlayList?wait       | 以wait选项打开**PlayList**        |
| /pps/media/Playlist?wait,delta | 以wait和delta选项打开**PlayList** |
| /pps/media/.all?wait           | 以wait代开**media**目录           |
| /pps/fish?notify=345:water     | 打开fish并关联到**.notify**组345  |



Note: 指定PPS路径名打开查询选项的语法对于任何熟悉**getsubopt()**库的人来说是很容易识别的。

支持的路径名打开选项包括如下

**backlog**=num_kb

​	在刷新OCB(开放控制块)之前，要保留的最大增量大小(以KB为单位)。

​	如果你不指定该选项，或者你指定为0，那么默认backlog值为256KB。

​	你可以覆盖该选项，通过在启动**pps**时指定 **-d**选项。**flow**与**backlog**选项是互斥的。

​	如果总累积增量大于num_kb，则生成清除通知：

```
|@objname
```

**cred**

​	输出该对象的凭据。你只能将此选项与**flow**或**server**选线结合使用。当一个新客户端连接到一个服务器或flow对象时，连接通知也包含客户端凭据，以如下形式：

```
+@objname.client_id.nnode_id.pprocess_id.uuser_id.ggroup_id.g...
```

**critical**

​	将发布者指定为对该对象至关重要。

**crypt**=domain

​	设置该对象的加密域。为了使用这个选项，你必须以**-p**选项启动**pps**，在一个包含加密域的电源安全分区上指定一个持久化存储位置。

​	将一个PPS对象分配给一个域意味着当它被保存在持久存储中时，它将被放入指定的加密域中。例如，这行代码：

```
open(“/pps/test_obj?crypt=10”, O_CREAT, 0666)
```

​	分配**test_obj** PPS对象的加密域为10，当其被保存在持久化存储中时。

​	如果你为相同的PPS对象但不同加密域打开多个文件描述符，最后一个将被使用。如下例子中，域使用11：

```
fd1 = open(“/pps/test_obj”, O_RDWR|O_CREAT, 0666);
fd2 = open(“/pps/test_obj?crypt=10”, O_RDWR, 0666);
fd3 = open(“/pps/test_obj?crypt=11”, O_RDWR, 0666);
```

**delta**

​	以增量模式打开对象。

**deltadir**

​	返回目录中所有对象（文件）的名称 - 仅对目录中的特殊 .all 对象有效。

​	如果目录中任何对象被创建或删除，这些变更将在他们的名称前添加**+**(创建)或者**-**(删除)来标记。此行为允许您在 PPS 中有效地执行 readdir() 并监视文件系统更改，而无需同时监视属性更改。

**f=**filter ...

​	根据所列属性的更改对通知进行过滤。

**flow**[=num_kb]

​	将对象视为服务器对象，并带有清除和溢出通知。可选的 num_kb 是最大积压大小（以千字节为单位）。如果你不指定或指定值为0，则默认256kb；你可以在运行**pps**时指定**-d**选项来覆盖该值。溢出通知格式如下：

```
^@objname
```

​	**flow**和**backlog**选项是互斥的。你可以使用**hiwater**搭配**flow**选项来生成溢出通知。

**hiwater**=hw_percent

​	将流量高水位线指定为客户端backlog的百分比。如果backlog超过该百分比，溢出通知将被生成。当总累积增量大小高于指定backlog的 hw_percent 时，将为每个缓冲的增量生成溢出通知。溢出通知的格式：

```
^@objname
```

​	你可以指定范围从1%~99%；如果不指定该选项，默认100%。hiwater 选项只能与 flow 选项结合使用。

**nopersist**

​	使对象非持久化。当系统重启时，对象不会存在。默认设置是所有对象是持久化的并且在重启时重新加载。

**notify**=id:value

​	将打开的文件描述符与指定id的通知组关联起来。在第一次从PPS根目录下的**.notify**文件读取时，id将被返回。该值是您想要与该组关联的任意字符串。

​	只要使用notify=查询打开的文件描述符上有数据可用，读取.notify文件就会返回字符串id:value。

**opens**

​	当打开数量变更时，更新_opens::rd,wr。该选项使你能够接受到打开一个对象进行读写的文件描述符数量。通知形式如下：

```
%@objname.read_count,write_count
```

​	每次读写者数量变化时，通知将被发送。这些数字在每次调用**open()**时增加，调用**close()**时减少。O_RDONLY增加读者数量，O_WRONLY增加写者数量，O_RDWR增加读写者的数量。例如，如果你使用如下代码创建PPS对象：

```
fd = open(“/pps/test_obj?opens”, O_CREAT|O_RDWR, 0666);
```

​	然后在从该文件描述符读取之后，将收到如下通知：

```
%@test_obj.1,1
```

​	如果你使用O_WRONLY打开相同的PPS对象，然后将产生如下通知：

```
%@test_obj.1,2
```

**reflect**

​	将对此对象所做的属性更改反射回它。

**server**

​	将发布者指定为对象的“服务器”

**verbose**[=level]

​	设置对象的冗余等级。如果没有设置，默认为9(最高)

**wait**

​	使用O_NONBLOCK打开文件，这样read()将阻塞直到对象变更或增量出现。



#### critical 选项

​	你可以使用critical选项作为一种机制来清除发布者异常终止时的属性。

​	如果在打开文件描述符进行写时使用此选项，则当文件描述符关闭时，PPS删除所有非持久属性，并在发送给订阅者的通知字符串中的对象名前添加 星号*****。PPS不提供删除属性的列表。

**重复的关键文件描述符**

​	对任意一个PPS对象来说，你不能拥有超过一个关键文件描述符。

​	文件描述符可以被拷贝，通过显式的(dup(), dup2(), fcntl()等)或隐式的(fork(), spawn()等)。重复的描述符实际上会增加底层关键描述符的引用计数。直到文件描述符的引用计数降至零（表明原始文件和所有副本都已关闭）时，才会触发关键对象所需的行为（易失性属性的通知和删除）。

​	但是，如果在关键模式下多次打开 PPS 对象，则每个文件描述符都将表现为关键描述符：如果任何一个文件描述符的引用计数降至零，即使其他描述符保持打开状态，也会触发该对象的通知和删除行为。



#### 过滤通知

​	你可以基于属性名称、属性值或者两者的结合过滤PPS通知。

​	为了过滤通知，使用如下语法：

```
f=attrspec{+attrspec}...
```

​	其中 attrspec 是属性规范，由属性名称或指定属性值的表达式组成。如果你想在属性被删除时得到通知，在它的名字前加上减号**-**即可

```
f=-attr
```

​	指定属性值的语法如下：

```
attroperatorvalue
```

​	其中 attr是属性名，operator是用于确定触发通知的阈值的运算符，value是用于比较的值

​	支持的运算符有：

- <，<=，>，>=，=，== 和 != 用于整数。整数值必须在**long long**的范围；否则被视为字符串。
- =，== 和 != 用于字符串。记住 = 和 == 是相同的。字符串的值可以包含字符 **+ **，但需要使用 **\\** 转义



​	如果你仅仅指定属性名，PPS将会该名称对应属性的任何更新通知你。如果你指定了名称、运算符、值，PPS将任何该名称属性设置的值满足给定运算符和表达式的更新通知你。

​	在全量和增量模式中，如果任何属性规范匹配，文件描述符将得到：

- 在全量模式下，整个对象被返回。
- 在增量模式下，只有指定属性被返回。其他属性的更改被过滤掉。



在如下例子中，对象被打开时名称为objname：

| 路径名                              | 返回说明                                 |
| ----------------------------------- | ---------------------------------------- |
| /pps/objname?delta,f=attr1+attr2    | 返回属性attr1和attr2的更新通知           |
| /pps/objname?delta,f=attr1<37       | 返回属性attr1值小于37的更新通知          |
| /pps/objname?f=attr2<0+attr2>100    | 返回100>attr2属性值>0范围的更新通知      |
| /pps/objname?delta,f=attr1=a\\+b    | 当attr1的字符串值为a+b时，返回更新通知   |
| /pps/objname?delta,f=attr1+attr2<10 | 当attr1与attr2的值小于10时，返回更新通知 |



### 对象与属性限定符

​	PPS支持对象和其属性的限定符。

​	对象和属性限定符被包含在方括号内([限定符])并且被作为包含对象或属性名称的行的前缀。如下限定符被支持：

​	**n** 

​		非持久化存储。如果你在一个对象上设置它，对象将变为非持久化。如果你对一个属性设置它，如果父对象时持久化的，属性将变为非持久化；否则限定符被忽略。

​	**i**

​		项，指定设置属性的项目。

Note:

- 默认情况下，限定符未被设置
- 在read()调用时，您将看到前面的限定符列表“[选项字母]”仅适用于已设置的选项。
- 属性选项始终位于特殊字符和对象或属性名称之前。

​	如果限定符之前没有任何内容，则设置该限定符。如果限定符之前是**减号-** ，则限定符被清除。如果限定符未指定，则限定符保持不变。例如：

| 操作                       | 指令                      |
| -------------------------- | ------------------------- |
| 设置非持久化限定符         | [n]url::www.qnx.com       |
| 清除非持久化限定符         | [-n]url::www.qnx.com      |
| 保持当前非持久化限定符不变 | url::www.qnx.com          |
| 添加一项hammer到集合       | [i]toolbox::hammer,       |
| 从集合中删除screwdriver    | [-i]toolbox::screwdriver, |



#### 非持久化限定符

​	你可以为对象和属性使用非持久化限定符。对于在系统重新启动后可能无效且不需要保存的属性非常有用。

​	如下表格米哦啊哈苏了在PPS对象和属性上设置非持久化的效果

| 语法 | 动作 | 对象                                                         | 属性                                   |
| ---- | ---- | ------------------------------------------------------------ | -------------------------------------- |
| n    | 设置 | 使对象和其属性非持久化；忽略设置到该对象属性上的任何持久化限定符 | 使属性非持久化                         |
| -n   | 清除 | 是对象持久化；对象属性的持久化由每个属性的限定符决定         | 是属性持久化，如果属性对象也是持久化时 |



​	对象的非持久化限定符设置会对象属性上的任何非持久化限定符，并且当你想要创建一个没有东西需要持久化的临时对象时，该操作将带来很大方便。



#### 项限定符

​	你只能对属性使用项限定符。它将使PPS把该限定符之后的值当做一个项的集合。

​	你必须选择一个字符，例如**逗号,** 来分隔集合中的项。项分隔符：

- 是必须的
- 必须是使用项限定符的值中的最后一个字符
- 可以是项中未使用的任何字符



你可以一次仅仅添加或删除一个项。例如，添加项到集合：

```
[i]toolbox::hammer,
[i]toolbox::screwdriver,
```

为从集合中删除一个项，指定**减号-**

```
[-i]toolbox::hammer,
```

以下的例子展示了**错误的**项语法并且是不被允许的：

```
[i]toolbox::hammer,screwdriver,
[-i]toolbox::hammer,screwdriver,
```

如果你添加一个项超过一次，PPS将忽略重复的尝试。例如：

```
[i]toolbox::hammer,
[i]toolbox::hammer,
[i]toolbox::screwdriver,
```

订阅者将读取到

```
toolbox::hammer,screwdriver,
```

你可以添加**空项**到一个集合，如下：

```
[i]toolbox::,
```

订阅者将读取到

```
toolbox::hammer,screwdriver,,
```

